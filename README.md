# GCP
# 谷歌云平台解决方案 :see_no_evil:


<a name="3060-1621846615933"></a><a name="i3iw-1703890508936"></a>[GCP 开发专业认证示例](#ufyh-1701975693298)

<a name="jybp-1703890508938"></a>[Cloud Storage](#25jy-1703889896088)

<a name="mqep-1703890508940"></a>[Cloud SQL](#mv1r-1703889896089)

<a name="qlev-1703890508942"></a>[BigQuery](#nx8n-1703889896090)

<a name="oksk-1703890508944"></a>[BigTable](#agrh-1703889896091)

<a name="v1uo-1703890508946"></a>[GCP概念介绍](#kpfy-1702330971738)

<a name="7dgy-1703890508948"></a>[虚拟机实例](#ggyv-1703541111637)

<a name="rsqv-1703890508950"></a>[.虚拟机实例创建](#cwxb-1703546395338)

<a name="yfwz-1703890508952"></a>[.自动扩缩实例组](#eoin-1703546407515)

<a name="rdyg-1703890508954"></a>[永久磁盘](#be5a-1703541270839)

<a name="5hfo-1703890508956"></a>[·可用区永久性磁盘:高效、可靠的块存储。](#nnug-1703612874892)

<a name="qm1u-1703890508958"></a>[1.增量快照](#ighl-1703613111760)

<a name="yh2g-1703890508960"></a>[·区域永久性磁盘:在两个可用区中复制的区域块存储。](#5h2a-1703612875334)

<a name="wwmb-1703890508962"></a>[·本地SSD:高性能暂时性本地块存储。](#pvwg-1703612926251)

<a name="pzbe-1703890508964"></a>[. Cloud Storage存储桶:经济实惠的对象存储。](#uabg-1703612875336)

<a name="ydel-1703890508966"></a>[.Filestore:适用于Google Cloud 用户的高性能文件存储。](#6kzl-1703612875338)

<a name="epng-1703890508968"></a>[永久性磁盘快照迁移虚拟机实例](#vxpl-1703612920413)

<a name="1s0q-1703890508970"></a>[镜像(创建实例)](#09yn-1703541282443)

<a name="1wpp-1703890508972"></a>[.公共映像](#mdjz-1703614307842)

<a name="rnln-1703890508974"></a>[.自定义映像(仅适用于您的Cloud项目)](#bh1n-1703614309803)

<a name="qcob-1703890508976"></a>[.自定义镜像复制虚拟机实例](#ulho-1703541313574)

<a name="sd3k-1703890508978"></a>[健康检查](#tarc-1703724449830)

<a name="tqjm-1703890508980"></a>[.概念](#rqxl-1703724471007)

<a name="le6z-1703890508983"></a>[.代管实例组设置健康检查](#i8fb-1703724480813)

<a name="cikw-1703890508985"></a>[Deployment Manager ](#yhzq-1616513583057)

<a name="kpwu-1703890508987"></a>[.概念&使用](#xdzn-1703725192671)

<a name="1wo6-1703890508989"></a>[配置](#2nza-1703727491343)

<a name="sxwe-1703890508991"></a>[模板](#kbmu-1703727491578)

<a name="tbrd-1703890508993"></a>[资源（yml）](#srgz-1703727491579)

<a name="wvya-1703890508995"></a>[类型](#1mij-1703727491580)

<a name="pcco-1703890508997"></a>[清单](#5yms-1703727491581)

<a name="oyl0-1703890508999"></a>[部署 ](#wrzx-1703727491582)

<a name="1qv9-1703890509001"></a>[IP地址](#aixa-1616512706321)

<a name="vheq-1703890509003"></a>[.临时外部ip(停止/删除资源即释放)](#e3rs-1703728098691)

<a name="xn1j-1703890509005"></a>[.静态外部ip(存续)](#es1k-1703731934318)

<a name="kiym-1703890509007"></a>[负载均衡(7层，4层)](#8m0l-1703731963710)

<a name="2dy7-1703890509009"></a>[内部HTTP(S)负载均衡 ](#qxfq-1703776527441)

<a name="l3cs-1703890509011"></a>[外部 HTTP(S)负载平衡](#zavj-1703776539919)

<a name="s0cq-1703890509013"></a>[内部 TCP/UDP负载平衡](#ysf5-1703776527746)

<a name="5epu-1703890509015"></a>[外部 TCP/UDP网络负载均衡](#rs4k-1703776527748)

<a name="84v6-1703890509017"></a>[外部 SSL代理负载均衡](#480j-1703776543001)

<a name="j4qo-1703890509019"></a>[外部 TCP代理负载均衡](#pmhc-1703776527750)

<a name="xvss-1703890509021"></a>[.基于目标池的外部TCP网络负载均衡器](#iti7-1703728091914)

<a name="fub0-1703890509023"></a>[.Armor(安全政策)](#2550-1595249949242)

<a name="hysd-1703890509025"></a>[.为负载均衡器设置Armor操作](#5cua-1703776702621)

<a name="en7n-1703890509027"></a>[Cloud Storage(对象存储(日志,图片))](#2422-1585069536532)

<a name="dr0p-1703890509029"></a>[.概念](#cste-1703802087930)

<a name="b16l-1703890509031"></a>[1.对象存储(日志,图片)](#baiz-1703803038821)

<a name="xeeg-1703890509033"></a>[2.保护数据安全(IAM,数据加密,身份验证,分区锁定，版本控制)](#9b82-1703803056615)

<a name="vanq-1703890509035"></a>[3.存储桶(基本容器)](#xfiw-1703802132873)

<a name="lg0c-1703890509037"></a>[.存储桶相关操作](#a4wj-1703803208413)

<a name="lvqn-1703890509039"></a>[.对象生命周期管理](#tmfk-1703802111046)

<a name="pznk-1703890509041"></a>[.Storage Transfer Service(多云数据转移)](#bp2u-1703802871900)

<a name="zf7h-1703890509043"></a>[Cloud SQL](#tvdh-1703804630431)

<a name="dvwl-1703890509045"></a>[.概念](#iczc-1703872944177)

<a name="8sfb-1703890509047"></a>[.for Mysql](#2c49-1703872957141)

<a name="6z3c-1703890509049"></a>[.数据库灾难恢复](#dst5-1703872971504)

<a name="iu35-1703890509051"></a>[1.使主实例不可用](#nvah-1703877658127)

<a name="jjou-1703890509053"></a>[2.实施灾难恢复](#uiqd-1703877659651)

<a name="7yzb-1703890509055"></a>[3.新主启用高可用](#ilev-1703877708388)

<a name="9a7y-1703890509057"></a>[BigQuery(数仓，Sql分析)](#ywx5-1703872998042)

<a name="2wan-1703890509059"></a>[.加载和查询数据](#y2zg-1703873024896)

<a name="um56-1703890509061"></a>[Bigtable(HBase竞品)](#bsyq-1703873049958)

<a name="hgz3-1703890509063"></a>[.数据写入与读取](#oejc-1703873059122)

<a name="qxws-1703890509065"></a>[ Firestore(会话存储)](#xdlt-1703873017651)

<a name="2ozk-1703890509068"></a>[Cloud Spanner(跨区域高可用)](#bh8z-1703872927361)

<a name="ymqk-1703890509070"></a>[Cloud Data Loss Prevention(损失预防/敏感数据)](#evlf-1703889764129)



<a name="ufyh-1701975693298"></a>**GCP 开发专业认证示例**

<a name="25jy-1703889896088"></a>**Cloud Storage**

<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>

您的团队正在为您的公司开发电子商务平台。用户将登录网站并将商品添加到他们的购物车中。用户将在 30 分钟不活动后自动注销。当用户重新登录时，

他们的购物车应该可用。在遵循 Google 推荐的最佳做法的同时，您应如何存储用户的会话和购物车信息？ 

A. 将会话和购物车信息存储在本地内存中，并在全局外部 HTTP（S） 负载平衡器中启用基于 Cookie 的会话相关性。 

B. 将购物车信息存储在 Cloud Storage 上的对象中，其中对象名称是会话标识符。  

C. 将会话和购物车信息存储在 BigQuery 中。 

D. 将会话信息存储在 Memorystore for Redis 中，将购物车信息存储在 Firestore 中。 

正确答案 

D. 将会话信息存储在 Memorystore for Redis 中，将购物车信息存储在 Firestore 中。 

反馈意见 A 不正确，因为本地内存在进程终止时会丢失，因此您将丢失购物车信息。 

B 不正确，因为访问 Cloud Storage 存储分区的速度较慢且会话信息成本高昂。这不是 Google Cloud 的最佳做法。 

C 不正确，因为 BigQuery 无法处理对购物车和会话进行的频繁更新。 

D 是正确的，因为 Memorystore 速度很快，是存储会话信息的标准解决方案，而 Firestore 是小型结构化数据（如购物车）的理想选择。如果需要，

用户将使用新会话映射到购物车。 

\==============================

您最近开发了一个网络应用，用于每天将日志数据传输到 Cloud Storage 存储分区。经过身份验证的用户将定期查看前两周的日志，以查找关键事件。

之后，外部审计师将每年审查一次日志。数据必须存储不少于 7 年。您希望提出一个满足这些要求并最大限度地降低成本的存储解决方案。你应该怎么做？

（二选一） 

A. 使用存储桶锁定功能设置数据的保留策略。  

B. 运行计划作业，将超过 14 天的对象的存储类设置为 Coldline。 

C. 为需要访问 Coldline 存储桶的用户创建 JSON Web 令牌 （JWT）。 

D. 创建生命周期管理策略，将超过 14 天的对象的存储类设置为 Coldline。 

E. 创建生命周期管理策略，将超过 14 天的对象的存储类设置为“近线”。 



正确答案 

A. 使用存储桶锁定功能设置数据的保留策略。 

D. 创建生命周期管理策略，将超过 14 天的对象的存储类设置为 Coldline。 

反馈意见 A 是正确的，因为存储桶锁定功能将强制执行所需的保留策略。 

B 不正确，因为应使用生命周期管理策略设置存储类。 

C 不正确。JWT 可用于身份验证，但不应用于确定对象生命周期。 

D 是正确的，因为生命周期管理策略将更改存储类以最大限度地降低成本。 

E 不正确，因为如果数据仅每年访问一次，则存档或 Coldline 存储比近线存储更经济。 

\==============================

您正在开发一个应用，用于存储和访问 Cloud Storage 存储分区中的对象。为了遵守法规要求，您需要确保所有对象在初始创建后至少 7 年内可用。

3 年多前创建的对象很少被访问（每年不到一次）。您需要配置对象存储，同时确保存储成本得到优化。你应该怎么做？（二选一） 

A. 在存储桶上设置保留策略，期限为 7 年。 

B. 在对象的前缀名称中包含创建时间，并使用 IAM 条件仅提供对对象创建日期后 7 年内对象的读取访问权限。 



C. 启用对象版本控制，以防止对象在创建后的 7 年内被意外删除。 

D. 在存储桶上创建对象生命周期策略，以便在 3 年后将对象从标准存储移动到存档存储。 

E. 实现一个 Cloud Function，用于检查存储桶中每个对象的期限，并将超过 3 年的对象移动到具有 Archive Storage 类的第二个存储桶。 

使用 Cloud Scheduler 按每日计划触发 Cloud Function。 



正确答案 

A. 在存储桶上设置保留策略，期限为 7 年。 

D. 在存储桶上创建对象生命周期策略，以便在 3 年后将对象从标准存储移动到存档存储。 

反馈意见 答是正确的，因为 Cloud Storage 提供了配置保留生命周期规则的选项。 

B 不正确，因为它不是实现数据保留要求的推荐方法。 

C 不正确，因为它不保证对象在创建对象后的 7 年内不会被删除。 

D 是正确的，因为它是实现存储生命周期策略以将对象从标准层移动到存档层的最简单且推荐的方法。 

E 不正确，因为您不需要两个存储桶来将对象存储在两个存储层上。 

\============================== 

您已经开发了一个应用程序，并希望将其托管在 Cloud Run 上。此应用程序将日志记录作为文本写入本地文件。您希望将日志写入 Cloud Logging，

同时尽量减少需要维护的代码量。你应该怎么做？ 

A：在代码中导入 Cloud Logging 库，并使用它来编写日志。 

B. 使用编程语言记录器将日志写入标准输出 （stdout） 和标准错误 （stderr） 流。 

C. 将日志文件公开给  www.mycompany.com/logs 。使用浏览器手动下载文件并将其上传到 Cloud Storage。 

D. 使用 cron 计划作业，每天将日志文件复制到 Cloud Storage 一次。  

正确答案 

B. 使用编程语言记录器将日志写入标准输出 （stdout） 和标准错误 （stderr） 流。 

反馈意见 一个。这是不正确的。虽然从技术上讲可以使用该库，但这将导致需要维护大量代码。 

湾。这是正确的。Cloud Run 通过 stdout 和 stderr 直接集成到 Cloud Logging。 

三.这是不正确的。此任务必须手动执行。此外，这种方法也不是最安全的。 

<a name="xlkn-1703802890641"></a>D.这是不正确的。虽然可以将数据复制到 Cloud Storage 存储分区中，但这并不能帮助我们实现在 Cloud Logging 中存储日志数据的目标。 

<a name="mv1r-1703889896089"></a>**Cloud SQL**

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SQL



您正在将应用部署在与 Cloud SQL 通信的 Google Kubernetes Engine 实例上。您将使用 Cloud SQL 身份验证代理，让您的应用能够使用与

应用实例关联的服务帐号与数据库进行通信。您希望对分配给服务帐户的角色遵循最小特权原则。你应该怎么做？ 

A. 分配“项目编辑者”角色。 B. 分配“项目所有者”角色。  C. 分配 Cloud SQL 客户端角色。 D. 分配 Cloud SQL 编辑者角色。 

正确答案 

C. 分配 Cloud SQL 客户端角色。 

反馈意见 A 不正确，因为服务帐号只需连接到 Cloud SQL，而 Google 建议的最佳做法是提供所需的最少访问权限。 

B 不正确，因为服务帐号只需连接到 Cloud SQL，而 Google 建议的最佳做法是提供所需的最少访问权限。 

C 是正确的，因为 Cloud SQL 客户端角色提供了连接到 Cloud SQL 所需的最低访问权限。 

D 不正确，因为服务帐号只需连接到 Cloud SQL，而 Google 建议的最佳做法是提供所需的最少访问权限。 

\============================

您的团队管理一个web应用程序，该应用程序目前将用户会话信息存储在一个在InstitutedPostgreSQL数据库中。

并将web应用程序迁移到GoogleCloud。您在迁移之后检测到了很高的延迟。您需要进行一些快速测试来收集数据点，

然后向您的技术领导提供建议，以提高性能并使其成为一种具有成本效益的解决方案。

.首先，您希望将数据库迁移到GoogleCloud，而不更改

架构，以查看延迟是否减少。

.接下来，您需要评估如何用云管理的NoSQL数据库替换PostgreSQL，以存储用户会话信息。

您希望使用托管服务并快速收集数据点。你该怎么做？

A：将数据库迁移到 Cloud SQL。然后将数据导入 Cloud Storage。 B. 将数据库迁移到 BigQuery。然后，以本机模式将数据导入 Firestore。 

C. 将数据库迁移到 Cloud SQL。然后，以本机模式将数据导入 Firestore。 

D. 在 Google Cloud 中创建 Compute Engine 虚拟机实例，并安装 PostgreSQL 和 MongoDB Server 软件。将数据库迁移到新的 PostgreSQL，

然后将数据迁移到 MongoDB。 

正确答案 

C. 将数据库迁移到 Cloud SQL。然后，以本机模式将数据导入 Firestore。 

反馈意见 A 不正确。Cloud Storage 不是用于存储用户会话信息的有效 NoSQL 数据库。 

B 不正确。BigQuery 是一个数据仓库。它对插入的行的更新/删除功能有限，因此对于用户会话数据来说是一个糟糕的选择，因为用户会话数据会随着与用

户会话的进行而变化。 

C 是正确的。Cloud SQL 是受管理的 PostgreSQL 数据库，迁移时无需更改任何架构。建议使用本机模式下的 Firestore 来存储用户会话信息，这是此

测试的自然选择。 

D 不正确。这不使用任何托管服务，并且会增加测试时间，因为它需要数据库服务器管理。 

\================================ 

贵公司有一款成功的多人游戏，在美国很受欢迎。现在，它希望扩展到其他地区。它正在推出一项新功能，允许用户交易积分。此功能将适用于全球用户。贵公司当前的MySQL 后端已达到托管游戏的 Compute Engine 

实例的限制。你的公司希望迁移到其他数据库，以提供跨区域的全局一致性和高可用性。他们应该选择哪个数据库？ 

A. BigQuery B. 云 SQL  C. 云扳手 D. 云大表 

正确答案 

C. 云扳手 

反馈意见 A 不正确，因为 BigQuery 不能用作事务性数据库。 

B 不正确，因为 Cloud SQL 无法提供跨区域的高可用性。 

C 是正确的，因为只有 Cloud Spanner 才能提供全局一致性和可用性。 

D 不正确，因为 Cloud Bigtable 不提供全局可用性。 

\================================  

您的公司计划扩展其分析用例。其中一个新用例要求数据分析师使用 SQL 近乎实时地分析事件。您期望快速增长，并希望尽可能多地使用托管服务。你应该怎么做？ 

A. 创建 Pub/Sub 主题和订阅。将事件从源流式传输到 Pub/Sub 主题。利用 Dataflow 将这些事件提取到 BigQuery 中。  

B. 创建发布/订阅主题和订阅。将事件从源流式传输到 Pub/Sub 主题。利用 Dataflow 将这些事件提取到 Cloud Storage 中。 

C. 创建发布/订阅主题和订阅。将事件从源流式传输到 Pub/Sub 主题。利用 Dataflow 以数据存储模式将这些事件摄取到 Firestore 中。 

D. 在大型 Compute Engine 实例上创建 Kafka 实例。将事件从源流式传输到 Kafka 管道。利用 Dataflow 将这些事件提取到 Cloud Storage 中。 

反馈意见 答是正确的，因为所涉及的所有三个产品都可以扩展到大量数据，并且将数据写入 BigQuery 允许通过 SQL 进行即时分析。 

B 不正确，因为 Cloud Storage 不适合插入单个事件并通过 SQL 对其进行分析。 

C 不正确，因为数据存储模式下的 Firestore 不适合插入单个事件并对其进行分析。 

<a name="savw-1703884741453"></a>D 不正确，因为此解决方案不提供完全托管的解决方案。 

<a name="nx8n-1703889896090"></a>**BigQuery**

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

您的团队开发了一个移动 Web 应用程序，全球用户可在其中对热门主题进行投票。对于每个主题，您预计在每个 30 分钟的投票窗口内会有非常高的投票量。您需要在每 30 分钟的窗口内捕获并计算每个主题的投票。您还需要存储选票以供将来分析和报告。你应该怎么做？ 

A：将投票保存到 Memorystore，然后使用 Cloud Functions 将计票结果插入到 BigQuery 中。在 Google Data Studio 中显示结果。

B. 将投票发布到 Pub/Sub，并使用 Datafow 管道将计票和投票插入到 BigQuery 中。在 Google Data Studio 中显示结果。 

C. 将投票发布到 Pub/Sub，并使用 Cloud Functions 将计票和投票插入到 Cloud Storage 中。在 Google Data Studio 中显示结果。 

D. 使用 Firebase 对移动用户进行身份验证，并将投票直接发布到 Firestore。将投票结果导出为 CSV 文件，然后将其导入 Google 表格以生成报告。 

反馈意见 A. 不正确。Memorystore 不是持久性数据存储，可能会丢失投票。 

B. 正确。Pub/Sub 支持每秒引入数百万条记录，并保证消息的传递。Dataflow 可以在按主题分组的窗口中聚合投票。应使用 BigQuery 进行分析。 

C. 不正确。使用 Cloud Functions 进行窗口化和分组需要将状态存储在中间数据存储中。此外，将原始数据存储在 blob 存储中会使使用 Data Studio 进行分析效率低下。 

D. 不正确。Google 表格可以执行的分组和分析操作存在限制。

\================================  

您的团队正在使用 Cloud Run 将每条发布/订阅消息写入 Cloud Storage 对象和 BigQuery 表。您希望将运营开销降至最低。您应该实现哪种架构？  

A 不正确，因为这会将一半的消息写入 BigQuery，另一半写入 Cloud Storage，这不符合需求。 -消息队列被消费

B 是正确的，因为每个 App Engine 服务都会收到自己的消息来写入，并且可以独立重试/失败。 

C 不正确，因为将邮件处理到一个系统时出现故障可能会导致重复写入 BigQuery 或 Google Cloud Storage。 

<a name="nks9-1703884709102"></a>D 不正确，因为它重复了消息发送费用，并要求将消息发送到两个不同的主题两次，这会增加成本、管理其他主题的需要以及客户端上的复杂性。

<a name="agrh-1703889896091"></a>**BigTable**

` `您正在分析应用程序的性能。您发现集群中某些 Cloud Bigtable 

表的使用量远远高于其他表，从而导致最终用户的应用性能不一致。您会发现某些平板电脑具有大量名称相似的行键，并且使用率很高，而其他平板电脑则处于空闲状态。您发现用户的邮政编码是行键的第一个组成部分，并且您的应用程序被源自该邮政编码的配置文件大量使用。您希望更改生成行键的方式，使其具有人类可读性，并使Cloud Bigtable 需求在集群中更均匀地分布。你应该怎么做？ 

A. 使用串行生成的整数值。 B. 使用行内容的 MD5 哈希的子集。  C. 使用多个人类可读属性的串联。 

D. 使用以毫秒为单位表示的 UNIX 纪元样式时间戳。 

正确答案 

C. 使用多个人类可读属性的串联。 

反馈意见 A 不正确，因为根据基础值的分布，串行生成的整数值可能会导致热点。 

B 不正确，因为这不再是推荐的最佳做法：它使解决问题变得困难。  

C 是正确的，因为使用足够数量的分隔属性可以提供足够的扩展。  

<a name="l11q-1703884660135"></a>D 不正确，因为时间戳不适合行键，在这种情况下，如果在同一毫秒内连续执行多个更新，则无意中导致 ID 冲突。 

<a name="ftmk-1703884660137"></a><a name="kpfy-1702330971738"></a>**GCP概念介绍**

.台湾节点

.AWS Azure GCP平台的比较

<a name="p89f-1703541130563"></a>.GCP认证

<a name="ggyv-1703541111637"></a>**虚拟机实例**

<a name="cwxb-1703546395338"></a>**.虚拟机实例创建**

<a name="eoin-1703546407515"></a>**.自动扩缩实例组**

本页面简要介绍了Compute Engine 实例。实例是Google基础架构上托管的虚拟机。您可以使用Google Cloud Console、Google Cloud CLI

或Compute Engine API创建实例或创建代管式实例组。

模板实例：虚拟机启动脚本，扩缩指标，cpu超60%

yum install -y

systemctl start httpd

<a name="lavd-1703541505718"></a>systemctl enable httpd

<a name="be5a-1703541270839"></a>**永久磁盘**

<a name="nnug-1703612874892"></a>**·可用区永久性磁盘:高效、可靠的块存储。**

<a name="ighl-1703613111760"></a>**1.增量快照**

<a name="5h2a-1703612875334"></a>**·区域永久性磁盘:在两个可用区中复制的区域块存储。**

<a name="pvwg-1703612926251"></a>**·本地SSD:高性能暂时性本地块存储。**

<a name="uabg-1703612875336"></a>**. Cloud Storage存储桶:经济实惠的对象存储。**

<a name="6kzl-1703612875338"></a>**.Filestore:适用于Google Cloud 用户的高性能文件存储。**

增量快照的工作原理如下:

·永久性磁盘的第一个成功快照是一个完整的快照，其中包含了该永久性磁盘上的所有数据。

第二个快照仅包含自从创建第一个快照以来的任何新增或修改的数据。自创建快照1以来未更改的数据不包括在内。对于任何未更改的数据，

快照2中包含了对快照1的引用。快照3中包含了自从创建快照⒉以来的任何新增或更改的数据，但不包含快照1或2中任何未更改的数据。

对于任何未更改的数据，快照3包含了对快照1和快照2中的磁盘块的引用 -即所有快照合起来才为完整数据

<a name="mejw-1703613057291"></a>永久性磁盘的所有后续快照都将重复此过程。系统始终是在上次成功获取的快照的基础上创建快照。

<a name="vxpl-1703612920413"></a>**永久性磁盘快照迁移虚拟机实例**

<a name="mz0d-1703614104543"></a>选择现有磁盘快照，(同步前一个虚拟机实例的区域与-httpd)

<a name="09yn-1703541282443"></a>**镜像(创建实例)**

<a name="mdjz-1703614307842"></a>**.公共映像**

<a name="bh1n-1703614309803"></a>**.自定义映像(仅适用于您的Cloud项目)**

使用操作系统映像可以为实例创建启动磁盘。您可以使用以下一种映像类型:

·公共映像由Google、开源社区及第三方供应商提供和维护。默认情况下，所有Google Cloud项目都可以访问这些映像，并可以使用它们创建实例。

<a name="nykm-1703614253918"></a>·自定义映像仅适用于您的Cloud项目。您可以从启动磁盘和其他映像创建自定义映像。然后使用自定义映像创建实例。

<a name="ulho-1703541313574"></a>**.自定义镜像复制虚拟机实例**

创建一个自定义镜像

<a name="0gfe-1703724525213"></a>通过镜像创建虚拟机实例

<a name="tarc-1703724449830"></a>**健康检查**

<a name="rqxl-1703724471007"></a>**.概念**

<a name="i8fb-1703724480813"></a>**.代管实例组设置健康检查**

console.cloud.google.cn

实例组->健康检查

<a name="vt2j-1703726521298"></a>创建代管实例组 自动修复 sele 健康检查

<a name="yhzq-1616513583057"></a>**Deployment Manager** 

<a name="xdzn-1703725192671"></a>**.概念&使用**

<a name="2nza-1703727491343"></a>**配置**

<a name="kbmu-1703727491578"></a>**模板**

<a name="srgz-1703727491579"></a>**资源（yml）**

<a name="1mij-1703727491580"></a>**类型**

<a name="5yms-1703727491581"></a>**清单**

<a name="wrzx-1703727491582"></a>**部署** 

CLI

vi vm.yml

官方文档命令 

<a name="8p7h-1703727883784"></a>qucikstart-deployment-vm

<a name="aixa-1616512706321"></a>**IP地址**

<a name="e3rs-1703728098691"></a>**.临时外部ip(停止/删除资源即释放)**

<a name="es1k-1703731934318"></a>**.静态外部ip(存续)**

<a name="spba-1703736544939"></a>VPC -> ip地址 

<a name="8m0l-1703731963710"></a>**负载均衡(7层，4层)**

<a name="qxfq-1703776527441"></a>**内部HTTP(S)负载均衡** 

<a name="zavj-1703776539919"></a>**外部 HTTP(S)负载平衡**

<a name="ysf5-1703776527746"></a>**内部 TCP/UDP负载平衡**

<a name="rs4k-1703776527748"></a>**外部 TCP/UDP网络负载均衡**

<a name="480j-1703776543001"></a>**外部 SSL代理负载均衡**

<a name="pmhc-1703776527750"></a>**外部 TCP代理负载均衡**

<a name="iti7-1703728091914"></a>**.基于目标池的外部TCP网络负载均衡器**

Ingress

内部HTTP(S)负载均衡 （7层）

外部 HTTP(S)负载平衡

Google Cloud外部TCP/UDP网络负载均衡（此后称为网络负载均衡）是区域级的非代理负载均衡器。

网络负载均衡在Virtual Private Cloud (VPC)网络内同一个区域中的后端虚拟机(VM)实例之间分配TCP和UDP流量。

网络负载均衡器可以接收以下任何一种流量:

. 互联网上的任何客户端

·具有外部IP的Google Cloud虚拟机

·可通过Cloud NAT 或基于实例的NAT访问互联网的 Google Cloud虚拟机

根据转发规则配置，每个基于目标池的网络负载均衡器都支持以下协议流量类型之一:（4层）

· TCP

. UDP

<a name="dvxb-1703776587051"></a>.TCP和UDP

<a name="2550-1595249949242"></a>**.Armor(安全政策)**

Google Cloud Armor可帮助您保护Google Cloud部署免受多种类型的威胁，包括分布式拒绝服务(DDoS)攻击以及跨站脚本攻击(XSS)和

SQL注入(SQLi)等应用攻击。Google Clpud Armor具有一些自动保护功能，还有一些您需要手动配置。本文档简要介绍了这些功能，

<a name="ahht-1703795656966"></a>其中一些仅适用于全球外部HTTP(S)负载均衡器和全球外部 HTTP(S)负载均衡器(经典版)--7层。

<a name="5cua-1703776702621"></a>**.为负载均衡器设置Armor操作**

仅演示， 需向谷歌申请limit

后端安全政策 -拒绝所有ip

<a name="gaf9-1703797873491"></a>边缘安全政策

<a name="2422-1585069536532"></a>**Cloud Storage(对象存储(日志,图片))**

<a name="cste-1703802087930"></a>**.概念**

<a name="baiz-1703803038821"></a>**1.对象存储(日志,图片)**

<a name="9b82-1703803056615"></a>**2.保护数据安全(IAM,数据加密,身份验证,分区锁定，版本控制)**

Cloud Storage是一项用于将您的对象存储在Google Cloud中的服务。对象是由任意格式的文件组成的不可变的数据段。对象存储在称为存储桶的容器中。

所有存储桶都与项目相关联，您可以在组织下对项目进行分组。Google Cloud中的每个项目、存储桶和对象都属于Google Cloud资源，ComputeEngine 

实例等也属于资源。

创建项目后，您可以创建Cloud Storage存储分区，上传对象至存储分区，以及从存储分区中下载对象。您还可以授予权限，使您的数据可供您指定的主帐

号访问;或者针对某些用例（例如托管网站)，使您的数据可供公共互联网上的所有人访问。

保护数据安全

将对象上传到Cloud Storage之后，您可以精细地控制数据保护和共享方式。您可以采用以下方法来保护上传到Cloud Storage的数据:

.ldentity and Access Management(桶级权限):使用IAM控制哪些人有权访问您的Google Cloud项目中的资源。资源包括Cloud Storage存储分区和对

，象以及其他Google Cloud 实体，如ComputeEngine 实例。您可以向主帐号授予对存储分区和对象的特定类型的访问权限，

例如update .create或delete。

·数据加密:默认情况下，Cloud Storage使用服务器端加密来加密您的数据。您还可以使用补充数据加密选项，例如客户管理的加密密钥(CMEK)和客户

提供的加密密钥(CSEK)。

·身份验证:确保访问您的数据的所有人都有正确的凭据。

·存储分区锁定:通过指定保留政策控制对象在存储分区中必须保留的时长。

<a name="qcsh-1703802466102"></a>·对象版本控制:如果您启用对象版本控制，则在替换或删除对象的有效版本时，该版本可以保留为非当前版本。

<a name="xfiw-1703802132873"></a>**3.存储桶(基本容器)**

存储分区是用于存放数据的基本容器。您在Cloud Storage 中存储的所有内容都必须包含在存储分区中。您可以使用存储桶来整理数据并控制数据的

访问权限，但与目录和文件夹不同，您无法嵌套存储桶。虽然一个项目或位置中可以拥有的存储桶数量没有限制，但您可以限制创建/删除存储桶的速率。

创建存储桶时，您可以为其指定全局唯一名称以及存放存储桶及其内容的地理位置。创建存储桶后，您无法更改其名称和位置，但可以删除并重新创建

存储桶以实现类似结果。另外，您也可以配置可选的存储桶设置，这些设置可在存储桶创建期间进行配置，并在以后更改

存储类别

下表总结了Cloud Storage提供的主要存储类别。如需了解完整讨论，请参阅类别说明。--降低存储费用

存储类别            API和gsutil的名称    最短存储时长    典型的每月可用性

Standard存储空间    STANDARD                无        ·多区域和双区域位置高于99.99%·各区域达99.99%

Nearline存储空间     NEARLINE                30天        ·多区域和双区域位置达99.95%·各区域达99.9%

Coldline存储空间    COLDLINE                90天        ·多区域和双区域位置达99.95%·各区域达99.9%

<a name="ayib-1703803233465"></a>Archive存储空间    ARCHIVE                365天        ·多区域和双区域位置达99.95%·各区域达99.9%

<a name="a4wj-1703803208413"></a>**.存储桶相关操作**

创建

<a name="hokb-1703803485681"></a>权限-公开-非公开

<a name="tmfk-1703802111046"></a>**.对象生命周期管理**

为了支持常见使用场景（例如为对象设置存留时间(TTL)、保留对象的非当前版本或"降级"对象的存储类别以帮助管理费用)，

Cloud Storage提供了对象生命周期管理功能。

本页面介绍了此功能，以及使用此功能时可用的选项。如需了解生命周期配置文件的通用格式,

请参阅适用于JSON的存储分区资源表示法或适用于XML的生命周期配置格式。

为了使用对象生命周期管理，您需要定义生命周期配置，该配置必须在存储桶上设置。该配置包含一组适用于存储分区中的当前和未来对象的规则。

当对象满足其中一个规则的条件时，Cloud Storage会自动对该对象执行指定的操作。以下是一些示例用例:

·将超过365天的对象的存储类别降级为Coldline存储空间。·删除2013年1月1日之前创建的对象。

·在启用版本控制的存储分区中仅保留每个对象的3个最新版本。

SetStorageClass

规则    添加规则    全部删除    操作    对象条件    适用于

设置为Nearline    对象更新已超过29天    t    

设置为Coldline    对象更新已超过87天    i

设置为Archive    对象更新已超过359天    t

<a name="b9k3-1703804076884"></a>删除对象        对象更新已超过717天

<a name="bp2u-1703802871900"></a>**.Storage Transfer Service(多云数据转移)**

使用Storage Transfer Service这款产品可以:

·将数据从其他云存储服务商或者从本地或云端POSIX文件系统转移或备份到Cloud Storage存储桶。

·在Cloud Storage存储分区之间移动数据，以便供不同的用户组或应用使用。·将数据从Cloud Storage转移到本地或云端文件系统

·在文件系统之间转移数据。

.在数据处理流水线或分析工作流中定期移动数据。

我们支持从以下云存储服务商进行转移:

. Amazon S3

<a name="ueya-1703804893172"></a>. Microsoft Azure Blob Storage

<a name="tvdh-1703804630431"></a>**Cloud SQL**

<a name="iczc-1703872944177"></a>**.概念**

Cloud SQL为本地MySQL、PostgreSQL和SQL Server数据库提供基于云的替代方案。如果您希望减少数据库管理时间，将更多时间投入使用数据库，

<a name="mjqe-1703873306303"></a>则应使用Cloud SQL。在Compute Engine、App Engine和Google Cloud中的其他服务上运行的许多应用都使用CloudSQL来存储数据库。

<a name="2c49-1703872957141"></a>**.for Mysql**

创建 for mysql实例

<a name="lakd-1703873540509"></a>终端连接测试

<a name="dst5-1703872971504"></a>**.数据库灾难恢复**

<a name="nvah-1703877658127"></a>**1.使主实例不可用**

<a name="uiqd-1703877659651"></a>**2.实施灾难恢复**

<a name="ilev-1703877708388"></a>**3.新主启用高可用**

. Cloud SQL的两个实例(主实例和备用实例了位于单个区域(主要区域)内的两个不同地区中。系统将使用区域永久性磁盘同步实例。

。一个Cloud SQL实例（跨区域只读副本）位于另一个区域(辅助区域)。对于灾难恢复，设置跨区域只读副本以使用只读副本设置与主实例同步（使用异步复制)。

·创建高可用性Cloud sQL for MySQL实例。

·使用Cloud sQL for MySQL在Google Cloud 上部署一个跨区域只读副本.

·使用Cloud sQL for MySQL模拟灾难和故障切换情况。

·了解通过将回退过程与Cloud sQl for MySQL搭配使用来恢复初始部署的步骤。

本文档仅重点介绍跨区域灾难恢复故障切换和回退过程。如需了解单区域高可用性故障切换过程请参阅高可用性配置概览。

使主实例不可用-避免脑裂

在以下步骤中，您将通过停止主实例来模拟灾难情况。如果将跨区域只读副本附加到主实例，您必须先分离副本，否则无法停止Cloud sQL 实例。

1\.在Cloud Shell中，从主实例移除跨区域只读副本:

gcloud sql instances patch $cross\_region\_replica\_name l--no-enable-database-replication

当系统提示时，请接受继续操作的选项。

2\.停止主数据库实例:

gcloud sql instances patch $primary\_name --activation-policy NEVER

实施灾难恢复

1\.在Cloud Shell中，将跨区域只读副本提升为独立实例:

gcloud sql instances promote-replica $cross\_region\_replica\_name

<a name="88hm-1703874039693"></a>手动与自动执行的优缺点

<a name="ywx5-1703872998042"></a>**BigQuery(数仓，Sql分析)**

BigQuery是一种全代管式企业数据仓库，可帮助您使用机器学习、地理空间分析和商业智能等内置功能管理和分析数据。BigQuery的无服务器架构允许您使用SQL查询来回答组织面临的最大问题，而无需管理基础架构。BigQuery的可扩缩、分布式分析引擎可让您在几秒钟内查询TB级数据，在几分钟内查询PB级数据。

BigQuery使用针对分析查询进行了优化的列式存储格式来存储数据。BigQuery在表、行和列中显示数据，并完全支持数据库事务语义(ACID)。BigQuery存储会自动跨多个位置进行复制，以提供高可用性。

·了解数据仓库和数据集市中BigQuery资源的常见组织模式。。了解数据集，这是BigQuery的表和视图的顶层容器。

·使用方下方式将数据加载到BigQuery 中:

·使用Storage Write API流式传输数据。

·从本地文件或Cloud Storage批量加载数据，这些数据使用以下格式: Avro、Parquet.ORC、cSv、JSON、Datastore、Firestore格式。

<a name="fdu8-1703879016487"></a>.BigQuery Data Transfer Service可自动注入数据。

<a name="y2zg-1703873024896"></a>**.加载和查询数据**

<a name="bsyq-1703873049958"></a>**Bigtable(HBase竞品)**

Cloud Bigtable是稀疏填充的表，可以扩展到数十亿行和数千列，可让您存储TB级甚至是PB级的数据。每行中都会有一个被编入索引的值;这个值称为行键。Bigtable 能够以低延迟方式存储大量单键数据。它可以低延迟地支持高读写吞吐量，是MapReduce操作的理想数据源。Bigtable通过多个客户端库公开给应用，包括适用于Java的Apache HBase库的受支持扩展程序。因此，它可与开源大数据软件的现有Apache生态系统集成在一起。与自行管理的HBase安装相比，Bigtable强大的后端服务器具有多项关键优势:



·超高扩缩能力。Bigtable的扩缩能力与集群中的机器数成正比。自行管理的HBase安装存在一个设计瓶颈，在达到特定阈值后会对性能造成限制。Bigtable不存在此瓶颈，因此您可以扩展集群以处理更多读取和写入操作。

·易于管理。Bigtable可以透明方式处理升级和重启，而且会自动保持高度的数据耐用性。要复制您的数据，只需为您的实例添加第二个集群，然后系统便会自动开始复制。无需管理副本或区域;只需设计好表的架构，Bigtable就会为您处理剩余的操作。

.无需停机即可调整集群大小。您可以扩大Bigtable集群，运行几个小时以处理某个大型负载，

您可以使用Bigtable来存储和查询以下所有类型的数据:

·时间序列数据，例如多个服务器在一段时间内的CPU和内存使用率。

·营销数据，例如购买记录和客户偏好设置。

·金融数据，例如交易记录、股票价格和货币汇率。

·物联网数据，例如来自电表/气表和家用电器的使用量报告。·图表数据，例如有用户相互间连接方式的信息。

其他存储和数据库选项

Bigtable不是关系型数据库，不支持SQL查询、联接或多行事务。

·如果您需要为联机事务处理(OLTP)系统提供全面的SQL支持，请考虑使用Cloud Spanner或Cloud SQL。

·如果您需要在一个在线分析处理(OLAP)系统中进行互动式查询，请考虑使用BigQuery。

·如果您必须将高度结构化的对象存储在文档数据库中，且支持ACID事务和SQL类查询，请考虑使用Firestore。

<a name="1zx9-1703888243041"></a>·如需以低延迟方式存储内存数据，请考虑使用Memorystore。·如需实时同步用户之间的数据，请考虑使用Firebase 实时数据库。

<a name="oejc-1703873059122"></a>**.数据写入与读取**

列族

<a name="upgu-1703889403023"></a>    c1：value

<a name="xdlt-1703873017651"></a> **Firestore(会话存储)**

<a name="rqfz-1703889554776"></a>是小型结构化数据（如购物车）的理想选择

<a name="bh8z-1703872927361"></a>**Cloud Spanner(跨区域高可用)**

<a name="evlf-1703889764129"></a>**Cloud Data Loss Prevention(损失预防/敏感数据)**

