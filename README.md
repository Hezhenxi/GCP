# GCP
# 谷歌云平台 :see_no_evil:


<a name="3060-1621846615933"></a><a name="i3iw-1703890508936"></a>[GCP 开发专业认证示例](#ufyh-1701975693298)

<a name="jybp-1703890508938"></a>[Cloud Storage](#25jy-1703889896088)

<a name="mqep-1703890508940"></a>[Cloud SQL](#mv1r-1703889896089)

<a name="qlev-1703890508942"></a>[BigQuery](#nx8n-1703889896090)

<a name="oksk-1703890508944"></a>[BigTable](#agrh-1703889896091)

<a name="v1uo-1703890508946"></a>[GCP概念介绍](#kpfy-1702330971738)

<a name="7dgy-1703890508948"></a>[虚拟机实例](#ggyv-1703541111637)

<a name="rsqv-1703890508950"></a>[.虚拟机实例创建](#cwxb-1703546395338)

<a name="yfwz-1703890508952"></a>[.自动扩缩实例组](#eoin-1703546407515)

<a name="rdyg-1703890508954"></a>[永久磁盘](#be5a-1703541270839)

<a name="5hfo-1703890508956"></a>[·可用区永久性磁盘:高效、可靠的块存储。](#nnug-1703612874892)

<a name="qm1u-1703890508958"></a>[1.增量快照](#ighl-1703613111760)

<a name="yh2g-1703890508960"></a>[·区域永久性磁盘:在两个可用区中复制的区域块存储。](#5h2a-1703612875334)

<a name="wwmb-1703890508962"></a>[·本地SSD:高性能暂时性本地块存储。](#pvwg-1703612926251)

<a name="pzbe-1703890508964"></a>[. Cloud Storage存储桶:经济实惠的对象存储。](#uabg-1703612875336)

<a name="ydel-1703890508966"></a>[.Filestore:适用于Google Cloud 用户的高性能文件存储。](#6kzl-1703612875338)

<a name="epng-1703890508968"></a>[永久性磁盘快照迁移虚拟机实例](#vxpl-1703612920413)

<a name="1s0q-1703890508970"></a>[镜像(创建实例)](#09yn-1703541282443)

<a name="1wpp-1703890508972"></a>[.公共映像](#mdjz-1703614307842)

<a name="rnln-1703890508974"></a>[.自定义映像(仅适用于您的Cloud项目)](#bh1n-1703614309803)

<a name="qcob-1703890508976"></a>[.自定义镜像复制虚拟机实例](#ulho-1703541313574)

<a name="sd3k-1703890508978"></a>[健康检查](#tarc-1703724449830)

<a name="tqjm-1703890508980"></a>[.概念](#rqxl-1703724471007)

<a name="le6z-1703890508983"></a>[.代管实例组设置健康检查](#i8fb-1703724480813)

<a name="cikw-1703890508985"></a>[Deployment Manager ](#yhzq-1616513583057)

<a name="kpwu-1703890508987"></a>[.概念&使用](#xdzn-1703725192671)

<a name="1wo6-1703890508989"></a>[配置](#2nza-1703727491343)

<a name="sxwe-1703890508991"></a>[模板](#kbmu-1703727491578)

<a name="tbrd-1703890508993"></a>[资源（yml）](#srgz-1703727491579)

<a name="wvya-1703890508995"></a>[类型](#1mij-1703727491580)

<a name="pcco-1703890508997"></a>[清单](#5yms-1703727491581)

<a name="oyl0-1703890508999"></a>[部署 ](#wrzx-1703727491582)

<a name="1qv9-1703890509001"></a>[IP地址](#aixa-1616512706321)

<a name="vheq-1703890509003"></a>[.临时外部ip(停止/删除资源即释放)](#e3rs-1703728098691)

<a name="xn1j-1703890509005"></a>[.静态外部ip(存续)](#es1k-1703731934318)

<a name="kiym-1703890509007"></a>[负载均衡(7层，4层)](#8m0l-1703731963710)

<a name="2dy7-1703890509009"></a>[内部HTTP(S)负载均衡 ](#qxfq-1703776527441)

<a name="l3cs-1703890509011"></a>[外部 HTTP(S)负载平衡](#zavj-1703776539919)

<a name="s0cq-1703890509013"></a>[内部 TCP/UDP负载平衡](#ysf5-1703776527746)

<a name="5epu-1703890509015"></a>[外部 TCP/UDP网络负载均衡](#rs4k-1703776527748)

<a name="84v6-1703890509017"></a>[外部 SSL代理负载均衡](#480j-1703776543001)

<a name="j4qo-1703890509019"></a>[外部 TCP代理负载均衡](#pmhc-1703776527750)

<a name="xvss-1703890509021"></a>[.基于目标池的外部TCP网络负载均衡器](#iti7-1703728091914)

<a name="fub0-1703890509023"></a>[.Armor(安全政策)](#2550-1595249949242)

<a name="hysd-1703890509025"></a>[.为负载均衡器设置Armor操作](#5cua-1703776702621)

<a name="en7n-1703890509027"></a>[Cloud Storage(对象存储(日志,图片))](#2422-1585069536532)

<a name="dr0p-1703890509029"></a>[.概念](#cste-1703802087930)

<a name="b16l-1703890509031"></a>[1.对象存储(日志,图片)](#baiz-1703803038821)

<a name="xeeg-1703890509033"></a>[2.保护数据安全(IAM,数据加密,身份验证,分区锁定，版本控制)](#9b82-1703803056615)

<a name="vanq-1703890509035"></a>[3.存储桶(基本容器)](#xfiw-1703802132873)

<a name="lg0c-1703890509037"></a>[.存储桶相关操作](#a4wj-1703803208413)

<a name="lvqn-1703890509039"></a>[.对象生命周期管理](#tmfk-1703802111046)

<a name="pznk-1703890509041"></a>[.Storage Transfer Service(多云数据转移)](#bp2u-1703802871900)

<a name="zf7h-1703890509043"></a>[Cloud SQL](#tvdh-1703804630431)

<a name="dvwl-1703890509045"></a>[.概念](#iczc-1703872944177)

<a name="8sfb-1703890509047"></a>[.for Mysql](#2c49-1703872957141)

<a name="6z3c-1703890509049"></a>[.数据库灾难恢复](#dst5-1703872971504)

<a name="iu35-1703890509051"></a>[1.使主实例不可用](#nvah-1703877658127)

<a name="jjou-1703890509053"></a>[2.实施灾难恢复](#uiqd-1703877659651)

<a name="7yzb-1703890509055"></a>[3.新主启用高可用](#ilev-1703877708388)

<a name="9a7y-1703890509057"></a>[BigQuery(数仓，Sql分析)](#ywx5-1703872998042)

<a name="2wan-1703890509059"></a>[.加载和查询数据](#y2zg-1703873024896)

<a name="um56-1703890509061"></a>[Bigtable(HBase竞品)](#bsyq-1703873049958)

<a name="hgz3-1703890509063"></a>[.数据写入与读取](#oejc-1703873059122)

<a name="qxws-1703890509065"></a>[ Firestore(会话存储)](#xdlt-1703873017651)

<a name="2ozk-1703890509068"></a>[Cloud Spanner(跨区域高可用)](#bh8z-1703872927361)

<a name="ymqk-1703890509070"></a>[Cloud Data Loss Prevention(损失预防/敏感数据)](#evlf-1703889764129)



<a name="ufyh-1701975693298"></a>**全球云服务厂商对比**

<a name="ewpv-1738742769521"></a>**总结**

<a name="vrcl-1738742816813"></a>AWS 凭借其 **最全面的产品矩阵、最强大的全球基础设施、最丰富的企业客户、最领先的AI/ML能力**，在全球云计算市场中长期占据领导地位。对于希望进行 **全球业务扩展、使用最成熟云服务、获得最佳性能和安全性** 的企业来说，AWS 仍然是最具竞争力的选择。

|<a name="l4sj-1738742770127"></a>**对比项**|<a name="vcbj-1738742770130"></a>**AWS**|<a name="rh3c-1738742770133"></a>**Azure**|<a name="wijf-1738742770136"></a>**Google Cloud**|<a name="pagd-1738742770139"></a>**Alibaba Cloud**|
| :- | :- | :- | :- | :- |
|<a name="fb35-1746687700140"></a>**市场占有率**|<a name="hvvh-1746687700143"></a>🏆 第一（33%）|<a name="sqkn-1746687700146"></a>第二（20%）|<a name="9xux-1746687700149"></a>第三（10%）|<a name="gxue-1746687700152"></a>亚洲市场领先（全球第四）|
|<a name="lrlx-1746687704509"></a>**产品数量**|<a name="3yov-1746687704512"></a>最全面，超200种|<a name="bbmz-1746687704515"></a>微软生态整合强|<a name="hapd-1746687704518"></a>AI和数据分析强|<a name="6ay2-1746687704521"></a>在中国市场最具竞争力|
|<a name="38xf-1746687709681"></a>**全球数据中心**|<a name="ati5-1746687709684"></a>最多，覆盖全球|<a name="8lf2-1746687709687"></a>次之，覆盖率较广|<a name="kzzl-1746687709690"></a>相对较少，但不断扩展|<a name="gpnb-1746687709693"></a>主要在亚洲，海外数据中心较少|
|<a name="70qc-1746687716313"></a>**AI/ML能力**|<a name="xw9u-1746687716316"></a>领先的SageMaker|<a name="5cel-1746687716319"></a>依托微软AI能力|<a name="hosl-1746687716322"></a>AI/ML能力最强|<a name="3f28-1746687716325"></a>在国内市场较强|
|<a name="crn7-1746687728023"></a>**大数据能力**|<a name="6utg-1746687728026"></a>Redshift、Athena等丰富|<a name="wmig-1746687728029"></a>与Microsoft Power BI整合|<a name="cfhg-1746687728032"></a>BigQuery全球领先|<a name="mhhy-1746687728035"></a>适合国内大数据处理|
|<a name="pqcb-1746687744138"></a>**企业客户**|<a name="y5cf-1746687744141"></a>Netflix、Airbnb、NASA等|<a name="c9qw-1746687744144"></a>SAP、Office 365等|<a name="bap1-1746687744147"></a>YouTube、Spotify等|<a name="vy3v-1746687744150"></a>阿里巴巴、国内企业|
|<a name="nzf5-1746687749435"></a>**价格模式**|<a name="kb8j-1746687749438"></a>按需付费+预留实例|<a name="hpsv-1746687749441"></a>结合微软企业套餐|<a name="pejd-1746687749444"></a>相对较低|<a name="dxju-1746687749447"></a>适合中国企业|

<a name="wjhe-1741341164062"></a><a name="dpwa-1738742755619"></a>**Google Cloud Platform主要服务**

![image.png](Aspose.Words.9ef7b296-9f1a-40ab-a590-52690825ce1f.001.png)

<a name="g24a-1703958573661"></a><a name="lviv-1703958571950"></a>GCP 服务更偏工程抽象，阿里云则是产品颗粒度更细。

<a name="xjej-1745006115483"></a>阿里云很多产品功能融合较强，可能一个 GCP 服务，对应阿里云多个组件组合。

<a name="r9sq-1745006115487"></a>Serverless 方面：GCP 的 Cloud Run + Cloud Functions 更细致，阿里云则统一走“函数计算 + 网关 + 流水线”模式。

<a name="n5ue-1745594804323"></a>**计算服务类**

|<a name="5xqv-1745005918053"></a>GCP 服务|<a name="sbbz-1745005918056"></a>阿里云对应服务|<a name="byhs-1745005918059"></a>简要说明|
| :- | :- | :- |
|<a name="j7fo-1745005918063"></a>**Compute Engine**|<a name="rl4a-1745005918066"></a>**ECS（弹性计算服务）**|<a name="so4r-1745005918069"></a>虚拟机服务|
|<a name="hxet-1745005918073"></a>**App Engine**|<a name="grfe-1745005918076"></a>**函数计算（FC）或 EDAS**|<a name="bhdj-1745005918079"></a>无需运维的 PaaS / Serverless 应用托管|
|<a name="abmg-1745005918083"></a>**Cloud Run**|<a name="v7nk-1745005918086"></a>**函数计算（FC）+ API 网关**|<a name="f0mn-1745005918089"></a>容器化 Serverless|
|<a name="smqk-1745005918093"></a>**GKE（Kubernetes Engine）**|<a name="exa1-1745005918096"></a>**ACK（容器服务 Kubernetes 版）**|<a name="7w97-1745005918099"></a>托管 Kubernetes|
|<a name="qf4m-1745005918103"></a>**Cloud Functions**|<a name="bqu3-1745005918106"></a>**函数计算（Function Compute）**|<a name="clke-1745005918109"></a>Serverless 函数|

<a name="wco0-1745005998443"></a>**Compute Engine**

<a name="1gmu-1745269963588"></a>相当于阿里云 **ECS 弹性计算服务**

<a name="t7le-1745320019809"></a>**App Engine 无需运维的 PaaS / Serverless 应用托管**

<a name="kikd-1745320019953"></a>Google App Engine（GAE）是 Google Cloud Platform（GCP）提供的全托管式无服务器计算平台，专注于托管网络应用程序和移动后端服务

<a name="mp8e-1745269944064"></a>**Managed Instance Group MIG 实例托管组**

<a name="rzx6-1745266863803"></a>相当于阿里云**弹性伸缩组（Auto Scaling Group）**

<a name="cnbw-1745269433948"></a>**Cloud Run  容器化serverless**

<a name="unka-1745320721967"></a>**Google Kubernetes Engine （GKE）**

<a name="4rkb-1745781998867"></a>相当于阿里云ACK（ali cotainer kubernets）

Role-Based Access Control RBAC  基于角色的访问控制

-rely on ephemeral volumens依赖临时卷,DiskPressure ，which Pod causing .  选check the container/ephemeral\_storage/used\_byte metric by using metrics  

PS:node/ephe  识别节点使用的总临时存储量，应该是选container 识别pod

IdentityAwareProxy(IAP)用于外部访问控制，而非内部命名空间隔离;RBAC更适合集群内权限管理。

-容器回滚到确切可运行版本 -使用sha256

-HPA Horizontal Pod Autoscaler

`  `水平Pod伸缩器



-如何结构化源代码控制库，用于IaC和应用代码

tettaform repo shared; Anthos cofigManagement repo shared; aplication code repo seperated ;different overlay is different enviroment ;different branch different feature.

<a name="s1fl-1745776086159"></a>-Anthos servise mesh安托斯服务网格

<a name="nfl7-1745698113328"></a>**CloudFunction**

<a name="bgw7-1745698142070"></a>  **函数计算（Function Compute）serverless函数**

-Cloud storage trigger的cloud function -云存储触发器云函数，自动扩展计算引擎扩展管理实例组

<a name="ki1n-1745782044668"></a>-Recommend API -通过使用这些API，开发者可以创建和管理推荐模型

<a name="dju2-1745269242618"></a>**存储与数据库**

|<a name="k10u-1745005954553"></a>GCP 服务|<a name="ibyx-1745005954556"></a>阿里云对应服务|<a name="rsyg-1745005954559"></a>简要说明|
| :- | :- | :- |
|<a name="oy8a-1745005954563"></a>**Cloud Storage**|<a name="mzyf-1745005954566"></a>**OSS（对象存储）**|<a name="xyud-1745005954569"></a>文件/对象存储|
|<a name="moxb-1745005954573"></a>**Cloud SQL**|<a name="eyf9-1745005954576"></a>**RDS（关系型数据库）**|<a name="kirq-1745005954579"></a>托管 MySQL / PostgreSQL|
|<a name="idgo-1745005954583"></a>**Firestore / Datastore**|<a name="e778-1745005954586"></a>**表格存储（Table Store）**|<a name="hhft-1745005954589"></a>NoSQL 数据库|
|<a name="vqpc-1745005954593"></a>**BigQuery**|<a name="auwp-1745005954596"></a>**MaxCompute / Hologres**|<a name="isqh-1745005954599"></a>数据仓库（大数据分析）|
|<a name="z1iv-1745005954603"></a>**Spanner**|<a name="plgm-1745005954606"></a>**PolarDB-X（或分布式 RDS）**|<a name="pl8i-1745005954609"></a>分布式数据库|
|<a name="mqcw-1747651996308"></a>BigTable|<a name="7c3y-1747651996311"></a>云数据库HBase版|<a name="ywpm-1747651996314"></a>非关系型数据库Hbase cassadra|

<a name="yz0n-1745004906743"></a>**BIGTable**

<a name="uhub-1747649937484"></a>非关系型数据库

<a name="tnts-1747649698334"></a>LSM树 key-value形式

<a name="eadn-1747649771616"></a>大数据系统设计思想

<a name="vjeq-1747649694382"></a>**BigQuery**

<a name="hrnj-1746722306244"></a>要按系统追踪成本，需为实例分配特定标签，并将计费数据导出到BigQuery进行查询。标签是用于成本细分的标准工具。

<a name="mug4-1746722297098"></a>**Cloud Storage 文件/对象存储**

<a name="tvya-1745782073117"></a>相当于阿里云 OSS Object Storage Service

<a name="xfci-1745354138519"></a>**Pub/Sub 消息**

<a name="jce7-1745782076560"></a>相当于阿里云 消息队列RocketMQ

吞吐量：百万级QPS          10万级QPS

延迟：毫秒级全球部署         毫秒级区域级部署

<a name="muzz-1745781809136"></a>-pub/Sub 高实时性

<a name="hmi3-1746722291011"></a>**网络和安全**

|<a name="ae9m-1745006039882"></a>GCP 服务|<a name="7rrv-1745006039885"></a>阿里云对应服务|<a name="uuf3-1745006039888"></a>简要说明|
| :- | :- | :- |
|<a name="7mio-1745006039893"></a>**VPC（虚拟私有云）**|<a name="z7ai-1745006039896"></a>**VPC（专有网络）**|<a name="t0hr-1745006039899"></a>网络隔离|
|<a name="yylg-1745006039903"></a>**Cloud Load Balancing**|<a name="vh62-1745006039906"></a>**SLB（负载均衡）**|<a name="boas-1745006039909"></a>应用层或传输层负载均衡|
|<a name="ygbd-1745006039913"></a>**Cloud CDN**|<a name="qn2w-1745006039916"></a>**阿里云 CDN**|<a name="unvy-1745006039919"></a>全球内容分发网络|
|<a name="qwkg-1745006039923"></a>**Cloud Armor**|<a name="kckb-1745006039926"></a>**Web 应用防火墙（WAF）**|<a name="auyg-1745006039929"></a>DDoS / 应用层防护|
|<a name="f7il-1745006039933"></a>**Cloud NAT / IAP**|<a name="o8pi-1745006039936"></a>**NAT 网关 / 安全堡垒机**|<a name="oooq-1745006039939"></a>出网控制 / 内网访问管理|

<a name="tavh-1745006031093"></a>**GCLB  Google Cloud Load Balancing**

相当于阿里云 SLB（Server Load Balancing）

-Ingress GKE中负载均衡器实现应用暴露与流量分发

<a name="5drl-1745781753360"></a>谷歌云‌GKE Ingress‌是GKE（Google Kubernetes Engine）中用于管理HTTP(S)流量路由的核心组件，通过原生集成Google Cloud负载均衡器实现应用暴露与流量分发

<a name="kgzo-1745781846135"></a>**VPC**

<a name="jrbh-1746738568675"></a>VPC流日志记录网络流量,卷设置为1.0表示记录所有流量。

<a name="ppl2-1746738563477"></a>**StackDriver Logging**

GCP Stackdriver‌是Google Cloud Platform（GCP）提供的一套全面的云监控、日志管理和错误报告工具。它可以帮助开发人员和运维团队实时监控应用程序和基础设施的性能和可用性，主要功能包括监控、日志管理和错误报告‌

相当于阿里云 云监控（CloudMonitor）‌与‌应用实时监控服务（ARMS）‌的组合

-Stackdriver(云监控、日志管理、错误报告) 需要安装agent

Stackdriver Logging‌

相当于阿里云 SLS日志服务

同时其部分功能延伸至‌操作审计（ActionTrail）‌和‌云监控（CloudMonitor）

-Fluentd 开源的日志收集和传输工具

PII信息泄露

-filter-recored-transformer过滤插件，在日志写入stackdriver前删除；解决 personally identifiable information (PIl) is leaking PII泄露问题  ps:Sd 本身的filter只能用于高级过滤，不能removeri日志条目

-使用Fluentd 的 filter-record-transformer 过滤插件filter从飞行日志中remove删除字段

-Loging Sink 日志沟槽

<a name="ywka-1746533436917"></a>Sink是一个配置，它定义了日志数据的目的地和导出方式。通过配置Sink，

<a name="ne8i-1746533385672"></a>**Stackdriver Monitoring**

-Stackdriver Monitoring‌   -Cloud Run 自动集成Cloud Monitoring,无需配置

相当于阿里云 云监控（CloudMonitor）

<a name="vqoa-1746533440511"></a>-‌OpenTelemetry  开源的监控系统 需要安装代理 agent

<a name="ip9d-1746533396338"></a>**Stackdriver Trace**

<a name="9df3-1746533404179"></a>**Stackdriver Profiler**

-Stackdriver Profiler‌ 云分析器

在功能定位上相当于阿里云的 ‌应用实时监控服务 ARMS

-不直接支持Clound run环境,

-收集详细的性能数据指标

-配置云性能分析器并初始化cloud.google.com/go/profiler库。云性能分析器旨在为生产环境中的低开销持续分析而设计。

<a name="lbh0-1745781602548"></a>-资源使用率detail

<a name="uijd-1745269407877"></a>** 

<a name="wuz3-1745269157997"></a>**身份与权限管理**

|<a name="yv5s-1745006148406"></a>GCP 服务|<a name="0h6k-1745006148409"></a>阿里云对应服务|<a name="nzzi-1745006148412"></a>简要说明|
| :- | :- | :- |
|<a name="urx2-1745006148416"></a>**IAM（Identity and Access Management）**|<a name="bbqu-1745006148419"></a>**RAM（访问控制）**|<a name="ycx4-1745006148422"></a>权限分配与策略管理|
|<a name="v44m-1745006148426"></a>**Organization + Folders**|<a name="drn2-1745006148429"></a>**资源目录（Resource Directory）**|<a name="dsto-1745006148432"></a>多账号统一管理|

<a name="3vji-1745006183727"></a>**二进制授权**

-IAM‌ 权限分配与策略管理

当于阿里云 RAM Resource Access Manager资源访问管理

-谷歌云二进制授权（Binary Authorization）‌是一种安全机制，用于确保只有经过审核和授权的容器镜像才能部署到生产环境

GKE：镜像

云原生应用

二进制授权

-Binary Authorization‌ 容器镜像的部署策略管控与安全验证

在功能定位上相当于阿里云 ‌容器镜像服务 ACR（Container Registry）

二进制attestor approval审批镜像部署

-Kubernetes中的二进制授权允许你强制规定只有经过一个或多个证明者批准的容器镜像才能部署到集群中。

<a name="dehb-1745781371482"></a>通过在Kubernetes集群内启用二进制授权，并将构建管道配置为证明者，你可以在代码更改推送到生产环境之前强制进行审批。

<a name="olzw-1745315231033"></a>**Key Management Service 秘钥管理服务**

<a name="vfpa-1745269207139"></a>**DevOps / 工具链**

|<a name="3d3v-1745006194868"></a>GCP 服务|<a name="dllj-1745006194871"></a>阿里云对应服务|<a name="unyn-1745006194874"></a>简要说明|
| :- | :- | :- |
|<a name="zsf6-1745006194878"></a>**Cloud Build**|<a name="giag-1745006194881"></a>**云效流水线 / CodePipeline**|<a name="19vm-1745006194884"></a>CI/CD 构建部署工具|
|<a name="7y8z-1745006194888"></a>**Artifact Registry**|<a name="obhg-1745006194891"></a>**阿里云制品库**|<a name="5d58-1745006194894"></a>存放镜像、包、依赖|
|<a name="ckl1-1745006194898"></a>**Cloud Scheduler**|<a name="lg75-1745006194901"></a>**定时任务服务 / 云函数 + 定时触发器**|<a name="5moe-1745006194904"></a>定时执行任务|
|<a name="ri2w-1745006194908"></a>**Operations（监控+日志）**|<a name="f6qc-1745006194911"></a>**云监控（CloudMonitor）+ 日志服务（SLS）**|<a name="zo75-1745006194914"></a>可观测性平台|
|<a name="e7wj-1745006194918"></a>**Secret Manager**|<a name="ormd-1745006194921"></a>**密钥管理服务（KMS）/ 配置服务 ACM**|<a name="a23c-1745006194924"></a>密钥与配置管理|

<a name="9yqf-1745006051340"></a>**Cloud Build  CICD构建部署工具**

<a name="y806-1745267424958"></a>相当于阿里云 **云效流水线/code pipeline**

-cloud storage fail:google api 403 -将roles/storage.objectAdmin身份和访问管理(IAM)角色授予CloudBuild.服务帐户在状态文件存储桶上

-HTTP liveness probe HTTP健壮性探针，现存活探针定期检查，重启403服务

<a name="ev9n-1745780329261"></a>-存活和就绪探针(Liveness/Readinessprobes）检查服务健康状态

<a name="xufi-1745685048292"></a>**Spinnaker**

开源的CD持续交付平台，Netflix开发

功能包括：

`    `集群管理

`    `部署管理

-GCR镜像仓库更新时部署应用：Pub/Sub 触发Spinnaker   -比使用Cloud Build更简单       

<a name="3avl-1746578275068"></a>GCR默认将镜像更新事件发布至Pub/Sub主题，配置Spinnaker监听该主题即可建立低代码的事件驱动流程

<a name="7jn6-1746578267250"></a>**Packer**

<a name="habd-1746532949010"></a>-混合云自定义custom镜像部署 -Packer允许您定义基础设施即代码，并支持多个云服务提供商，确保能够适应多云环境中的未来变化。

<a name="sowi-1746532934919"></a>**Artifact Registry**

Artifact Registry(镜像，依赖包)

` `Artifact指软件开发流程中生成的文件或数据，例如容器镜像、编译后的二进制文件、语言依赖包（如 Maven、npm）、测试报告等48。

谷歌云 Artifact Registry 即为此类制品的托管平台，支持统一存储与全生命周期管理15。

-Helm图表+container容器存储库：Artifact Registry提供了一个集中、安全的，符合GCRs标准的存储库

<a name="mntz-1746532818981"></a>-Artifact Registry是Google针对OCI对象的托管解决方案，可提供安全性和VPC集成。

<a name="htz4-1746532773780"></a>**SecretManager**

提供了一个集中和安全的秘密存储，允许您存储和检索API密钥。

-三方API需要秘钥key来调用时 -key as secrite 存储到SecretManager,通过环境变量的方式引用该秘钥

<a name="fkgo-1745777778909"></a>-cloud run 启动程序需要密码，24小时轮准一次：-将密码存储secret manager中，将秘钥作为卷挂载到应用程序(可零停机获取最新版本)

<a name="oazk-1745782163201"></a>**Terraform**

<a name="wn1n-1745426353286"></a>GCS  Google Cloud Storage:确保环境一致性

config connect

-谷歌云官方IaC工具.遵循GitOps，确保基础设施定期reconcile协调，避免配置drift漂移

Anthos Config Management

<a name="qqxs-1745782147033"></a>-定义GKE中的constranit template约束模板 如：GKE API

<a name="k9ef-1745782140076"></a><a name="zj0o-1745782140277"></a>**‌蓝绿部署：流量全切(蓝-绿)，及时回滚**

<a name="zdwh-1745665840475"></a>维护两套独立且完整的环境，蓝色为旧版本，绿色为新版本

<a name="inkx-1745533297925"></a>0停机要求严格的场景金融系统，A/B测试需求

<a name="oifl-1745533370757"></a>强稳定性，

<a name="rfbq-1745533505838"></a>但风险高，需要全切

<a name="lc8h-1745533430308"></a>适合低风险的场景

<a name="cjyf-1745353244121"></a>**金丝雀部署：流量逐步，可控的方式让部分用户测试新版本**

<a name="xp2o-1745533351584"></a>逐渐验证的复杂系统

<a name="nb1s-1745533375831"></a>灵活，

<a name="5efv-1745533504245"></a>风险低

<a name="29fb-1745533395345"></a>性能未知/部分测试发布

<a name="rgzn-1745353225375"></a>**SRE原则**

<a name="desh-1745330856774"></a>**错误预算（Error Budget）在特定时间段内系统可以容忍的错误或故障数量。**

<a name="eycg-1745331029180"></a>功能和系统稳定性之间找到平衡，确保用户满意度下的灵活性

<a name="d1km-1745338230852"></a>其与SLO服务级别目标相关联

<a name="orut-1745330886211"></a>**风险管理**

<a name="ruag-1745330906173"></a>求考虑各种可能发生的风险和异常情况，并制定相应的应对措施。

<a name="qrpx-1745330919182"></a>渐进式推出回滚

<a name="uwb2-1745330922648"></a>快速定位修复，事后总结根本原因，防止再次发生，而不是追究个人责任

<a name="ck8x-1745330956581"></a>**持续 学习和改进**

<a name="tmsj-1745330971791"></a>定期负载测试，压力测试，混沌测试

<a name="2n2h-1745330986570"></a>鼓励饰演和创新，从失败中汲取经验教训

<a name="tyw8-1745331065922"></a>**自动化**

<a name="htxx-1745331081682"></a>提高效率，减少错误和不确定性

<a name="t5s9-1745330803832"></a>**SLA（Service Level Agreement）‌是指服务级别协议 法律合同，可用性、响应时间、补偿措施**

<a name="yspi-1745269713421"></a>**‌SLO（Service Level Objective）‌是指服务级别目标  延迟指标具体指标，不到两秒播放，且一周内99达到此目标**

<a name="q10u-1745269718201"></a>**‌SLI（Service Level Indicator）‌是指服务级别指标   成功可用性达到指标的比例：不到两秒播放的比例**  

‌SLA（Service Level Agreement）‌是指服务级别协议，它是服务提供商与客户之间签订的法律合同，明确了服务提供商在服务质量和性能方面的承诺。SLA通常包括服务提供商与客户之间的具体条款和条件，例如服务的可用性、响应时间等，并且规定了如果服务未达到这些标准时的补偿措施‌12。

‌SLO（Service Level Objective）‌是指服务级别目标，它是服务提供商期望达到的服务水平目标。SLO是具体的、可衡量的指标，用于指导服务提供商如何提供服务。例如，一个Web应用程序的SLO可能是视频在不到两秒内开始播放，且在一周内99%的时间内达到这个目标‌2。

‌SLI（Service Level Indicator）‌是指服务级别指标，它是用来衡量服务实际表现的具体指标。SLI用于监测和评估服务的实际性能，帮助服务提供商了解其是否达到了SLO。例如，视频在不到两秒内开始播放的比例就是一个SLI，通过这个指标可以知道实际表现与SLO的差距‌12。

<a name="h89o-1745269697550"></a>-可用性服务级别指标（SLI)应衡量成功请求的比例

<a name="fcbz-1745781531680"></a><a name="qd4q-1745426328285"></a>**AI / ML / 数据分析**

|<a name="mqsv-1745006166448"></a>GCP 服务|<a name="bxkr-1745006166451"></a>阿里云对应服务|<a name="jpif-1745006166454"></a>简要说明|
| :- | :- | :- |
|<a name="bu3m-1745006166458"></a>**Vertex AI**|<a name="uh9m-1745006166461"></a>**PAI（机器学习平台）**|<a name="f3vb-1745006166464"></a>全托管 AI/ML 平台|
|<a name="kiuv-1745006166468"></a>**AI Platform Notebooks**|<a name="wrkj-1745006166471"></a>**PAI-DSW（开发工作台）**|<a name="34ae-1745006166474"></a>Jupyter Notebook 环境|
|<a name="38zf-1745006166478"></a>**Dataflow**|<a name="ztkb-1745006166481"></a>**DataWorks + E-MapReduce**|<a name="9lsv-1745006166484"></a>流式/批量数据处理|
|<a name="gttb-1745006166488"></a>**Pub/Sub**|<a name="liw4-1745006166491"></a>**消息队列（MQ）/ EventBridge**|<a name="jm3t-1745006166494"></a>消息推送和异步通信|

<a name="rq19-1745006051503"></a>**  

<a name="nn2o-1745269011442"></a><a name="ms9d-1745006051902"></a>**图1.部署在Google Cloud上的典型多层Web应用。**

![image.png](Aspose.Words.9ef7b296-9f1a-40ab-a590-52690825ce1f.002.png)

<a name="0pjd-1703960346839"></a><a name="un2p-1703960283871"></a>**图7.零信任微服务环境中的应用交付。**

![image.png](Aspose.Words.9ef7b296-9f1a-40ab-a590-52690825ce1f.003.png)

<a name="hvhk-1703960929789"></a><a name="iclq-1703960284232"></a>**网格入站网关流量**

![image.png](Aspose.Words.9ef7b296-9f1a-40ab-a590-52690825ce1f.004.png)

<a name="qtso-1703961239891"></a><a name="wdy9-1703961083013"></a>**GCP概念介绍**

.台湾节点

.AWS Azure GCP平台的比较

<a name="p89f-1703541130563"></a>.GCP认证

<a name="ggyv-1703541111637"></a><a name="yvvb-1740760310236"></a>**虚拟机实例**

<a name="cwxb-1703546395338"></a>**.虚拟机实例创建**

<a name="eoin-1703546407515"></a>**.自动扩缩实例组**

本页面简要介绍了Compute Engine 实例。实例是Google基础架构上托管的虚拟机。您可以使用Google Cloud Console、Google Cloud CLI

或Compute Engine API创建实例或创建代管式实例组。

模板实例：虚拟机启动脚本，扩缩指标，cpu超60%

yum install -y

systemctl start httpd

<a name="lavd-1703541505718"></a>systemctl enable httpd

<a name="be5a-1703541270839"></a><a name="zraa-1741004553576"></a>**永久磁盘**

<a name="nnug-1703612874892"></a>**·可用区永久性磁盘:高效、可靠的块存储。**

<a name="ighl-1703613111760"></a>**1.增量快照**

<a name="5h2a-1703612875334"></a>**·区域永久性磁盘:在两个可用区中复制的区域块存储。**

<a name="pvwg-1703612926251"></a>**·本地SSD:高性能暂时性本地块存储。**

<a name="uabg-1703612875336"></a>**. Cloud Storage存储桶:经济实惠的对象存储。**

<a name="6kzl-1703612875338"></a>**.Filestore:适用于Google Cloud 用户的高性能文件存储。**

增量快照的工作原理如下:

·永久性磁盘的第一个成功快照是一个完整的快照，其中包含了该永久性磁盘上的所有数据。

第二个快照仅包含自从创建第一个快照以来的任何新增或修改的数据。自创建快照1以来未更改的数据不包括在内。对于任何未更改的数据，

快照2中包含了对快照1的引用。快照3中包含了自从创建快照⒉以来的任何新增或更改的数据，但不包含快照1或2中任何未更改的数据。

对于任何未更改的数据，快照3包含了对快照1和快照2中的磁盘块的引用 -即所有快照合起来才为完整数据

<a name="mejw-1703613057291"></a>永久性磁盘的所有后续快照都将重复此过程。系统始终是在上次成功获取的快照的基础上创建快照。

<a name="vxpl-1703612920413"></a>**永久性磁盘快照迁移虚拟机实例**

<a name="mz0d-1703614104543"></a>选择现有磁盘快照，(同步前一个虚拟机实例的区域与-httpd)

<a name="09yn-1703541282443"></a>**镜像(系统镜像创建实例)**

<a name="mdjz-1703614307842"></a>**.公共映像**

<a name="bh1n-1703614309803"></a>**.自定义映像(仅适用于您的Cloud项目)**

使用操作系统映像可以为实例创建启动磁盘。您可以使用以下一种映像类型:

·公共映像由Google、开源社区及第三方供应商提供和维护。默认情况下，所有Google Cloud项目都可以访问这些映像，并可以使用它们创建实例。

<a name="nykm-1703614253918"></a>·自定义映像仅适用于您的Cloud项目。您可以从启动磁盘和其他映像创建自定义映像。然后使用自定义映像创建实例。

<a name="ulho-1703541313574"></a>**.自定义镜像复制虚拟机实例**

创建一个自定义镜像

<a name="0gfe-1703724525213"></a>通过镜像创建虚拟机实例

<a name="tarc-1703724449830"></a>**健康检查**

<a name="rqxl-1703724471007"></a>**.概念**

<a name="i8fb-1703724480813"></a>**.代管实例组设置健康检查**

console.cloud.google.cn

实例组->健康检查

<a name="vt2j-1703726521298"></a>创建代管实例组 自动修复 sele 健康检查

<a name="yhzq-1616513583057"></a>**Deployment Manager** 

<a name="xdzn-1703725192671"></a>**.概念&使用**

<a name="2nza-1703727491343"></a>**配置**

<a name="kbmu-1703727491578"></a>**模板**

<a name="srgz-1703727491579"></a>**资源（yml）**

<a name="1mij-1703727491580"></a>**类型**

<a name="5yms-1703727491581"></a>**清单**

<a name="wrzx-1703727491582"></a>**部署** 

CLI

vi vm.yml

官方文档命令 

<a name="8p7h-1703727883784"></a>qucikstart-deployment-vm

<a name="aixa-1616512706321"></a>**IP地址**

<a name="e3rs-1703728098691"></a>**.临时外部ip(停止/删除资源即释放)**

<a name="es1k-1703731934318"></a>**.静态外部ip(存续)**

<a name="spba-1703736544939"></a>VPC -> ip地址 

<a name="8m0l-1703731963710"></a>**负载均衡(7层/L7,4层/L4)Ingress**

<a name="qxfq-1703776527441"></a>**内部HTTP(S)负载均衡** 

<a name="zavj-1703776539919"></a>**外部 HTTP(S)负载平衡**

<a name="ysf5-1703776527746"></a>**内部 TCP/UDP负载平衡**

<a name="rs4k-1703776527748"></a>**外部 TCP/UDP网络负载均衡**

<a name="480j-1703776543001"></a>**外部 SSL代理负载均衡**

<a name="pmhc-1703776527750"></a>**外部 TCP代理负载均衡**

<a name="iti7-1703728091914"></a>**.基于目标池的外部TCP网络负载均衡器**

Ingress

内部HTTP(S)负载均衡 （7层）

外部 HTTP(S)负载平衡

Google Cloud外部TCP/UDP网络负载均衡（此后称为网络负载均衡）是区域级的非代理负载均衡器。

网络负载均衡在Virtual Private Cloud (VPC)网络内同一个区域中的后端虚拟机(VM)实例之间分配TCP和UDP流量。

网络负载均衡器可以接收以下任何一种流量:

. 互联网上的任何客户端

·具有外部IP的Google Cloud虚拟机

·可通过Cloud NAT 或基于实例的NAT访问互联网的 Google Cloud虚拟机

根据转发规则配置，每个基于目标池的网络负载均衡器都支持以下协议流量类型之一:（4层）

· TCP

. UDP

<a name="dvxb-1703776587051"></a>.TCP和UDP

<a name="2550-1595249949242"></a>**.Armor(安全政策,DDos,准入IP)**

Google Cloud Armor可帮助您保护Google Cloud部署免受多种类型的威胁，包括分布式拒绝服务(DDoS)攻击以及跨站脚本攻击(XSS)和

SQL注入(SQLi)等应用攻击。Google Clpud Armor具有一些自动保护功能，还有一些您需要手动配置。本文档简要介绍了这些功能，

<a name="ahht-1703795656966"></a>其中一些仅适用于全球外部HTTP(S)负载均衡器和全球外部 HTTP(S)负载均衡器(经典版)--7层。

<a name="5cua-1703776702621"></a>**.为负载均衡器设置Armor操作**

仅演示， 需向谷歌申请limit

后端安全政策 -拒绝所有ip

<a name="gaf9-1703797873491"></a>边缘安全政策

<a name="gjla-1704131795897"></a>**Cloud Run**

0-X实例扩缩

<a name="m0jz-1704131868452"></a>在完全托管的环境中快速、安全地部署和扩展应用程序

<a name="jdgb-1704131855115"></a>**Cloud Kurbernets Engine**

更便捷的k8s

create my-first-clusters1  -> go cloud shell

nginx.yaml

`    `apiversion: v1kind: Pod

`    `metadata:

`        `name: nginx

`    `spec:

`        `containers:

`            `- name: nginx

`            `image: nginx

`            `ports:

`            `- name: web

`                `containerPort: 80

<a name="lelk-1704131931124"></a>create pod: kubectl apply -f nginx.yml

<a name="f4pw-1704131882886"></a>**Cloud Storage(对象存储(日志,图片))**

<a name="cste-1703802087930"></a>**.概念**

<a name="baiz-1703803038821"></a>**1.对象存储(日志,图片)**

<a name="9b82-1703803056615"></a>**2.保护数据安全(IAM,数据加密,身份验证,分区锁定，版本控制)**

Cloud Storage是一项用于将您的对象存储在Google Cloud中的服务。对象是由任意格式的文件组成的不可变的数据段。对象存储在称为存储桶的容器中。

所有存储桶都与项目相关联，您可以在组织下对项目进行分组。Google Cloud中的每个项目、存储桶和对象都属于Google Cloud资源，ComputeEngine 

实例等也属于资源。

创建项目后，您可以创建Cloud Storage存储分区，上传对象至存储分区，以及从存储分区中下载对象。您还可以授予权限，使您的数据可供您指定的主帐

号访问;或者针对某些用例（例如托管网站)，使您的数据可供公共互联网上的所有人访问。

保护数据安全

将对象上传到Cloud Storage之后，您可以精细地控制数据保护和共享方式。您可以采用以下方法来保护上传到Cloud Storage的数据:

.ldentity and Access Management(桶级权限):使用IAM控制哪些人有权访问您的Google Cloud项目中的资源。资源包括Cloud Storage存储分区和对

，象以及其他Google Cloud 实体，如ComputeEngine 实例。您可以向主帐号授予对存储分区和对象的特定类型的访问权限，

例如update .create或delete。

·数据加密:默认情况下，Cloud Storage使用服务器端加密来加密您的数据。您还可以使用补充数据加密选项，例如客户管理的加密密钥(CMEK)和客户

提供的加密密钥(CSEK)。

·身份验证:确保访问您的数据的所有人都有正确的凭据。

·存储分区锁定:通过指定保留政策控制对象在存储分区中必须保留的时长。

<a name="qcsh-1703802466102"></a>·对象版本控制:如果您启用对象版本控制，则在替换或删除对象的有效版本时，该版本可以保留为非当前版本。

<a name="xfiw-1703802132873"></a>**3.存储桶(基本容器)**

存储分区是用于存放数据的基本容器。您在Cloud Storage 中存储的所有内容都必须包含在存储分区中。您可以使用存储桶来整理数据并控制数据的

访问权限，但与目录和文件夹不同，您无法嵌套存储桶。虽然一个项目或位置中可以拥有的存储桶数量没有限制，但您可以限制创建/删除存储桶的速率。

创建存储桶时，您可以为其指定全局唯一名称以及存放存储桶及其内容的地理位置。创建存储桶后，您无法更改其名称和位置，但可以删除并重新创建

存储桶以实现类似结果。另外，您也可以配置可选的存储桶设置，这些设置可在存储桶创建期间进行配置，并在以后更改

存储类别

下表总结了Cloud Storage提供的主要存储类别。如需了解完整讨论，请参阅类别说明。--降低存储费用

存储类别            API和gsutil的名称    最短存储时长    典型的每月可用性

Standard存储空间    STANDARD                无        ·多区域和双区域位置高于99.99%·各区域达99.99%

Nearline存储空间     NEARLINE                30天        ·多区域和双区域位置达99.95%·各区域达99.9%

Coldline存储空间    COLDLINE                90天        ·多区域和双区域位置达99.95%·各区域达99.9%

<a name="ayib-1703803233465"></a>Archive存储空间    ARCHIVE                365天        ·多区域和双区域位置达99.95%·各区域达99.9%

<a name="a4wj-1703803208413"></a>**.存储桶相关操作**

创建

<a name="hokb-1703803485681"></a>权限-公开-非公开

<a name="tmfk-1703802111046"></a>**.对象生命周期管理**

为了支持常见使用场景（例如为对象设置存留时间(TTL)、保留对象的非当前版本或"降级"对象的存储类别以帮助管理费用)，

Cloud Storage提供了对象生命周期管理功能。

本页面介绍了此功能，以及使用此功能时可用的选项。如需了解生命周期配置文件的通用格式,

请参阅适用于JSON的存储分区资源表示法或适用于XML的生命周期配置格式。

为了使用对象生命周期管理，您需要定义生命周期配置，该配置必须在存储桶上设置。该配置包含一组适用于存储分区中的当前和未来对象的规则。

当对象满足其中一个规则的条件时，Cloud Storage会自动对该对象执行指定的操作。以下是一些示例用例:

·将超过365天的对象的存储类别降级为Coldline存储空间。·删除2013年1月1日之前创建的对象。

·在启用版本控制的存储分区中仅保留每个对象的3个最新版本。

SetStorageClass

规则    添加规则    全部删除    操作    对象条件    适用于

设置为Nearline    对象更新已超过29天    t    

设置为Coldline    对象更新已超过87天    i

设置为Archive    对象更新已超过359天    t

<a name="b9k3-1703804076884"></a>删除对象        对象更新已超过717天

<a name="bp2u-1703802871900"></a>**.Storage Transfer Service(多云数据转移)**

使用Storage Transfer Service这款产品可以:

·将数据从其他云存储服务商或者从本地或云端POSIX文件系统转移或备份到Cloud Storage存储桶。

·在Cloud Storage存储分区之间移动数据，以便供不同的用户组或应用使用。·将数据从Cloud Storage转移到本地或云端文件系统

·在文件系统之间转移数据。

.在数据处理流水线或分析工作流中定期移动数据。

我们支持从以下云存储服务商进行转移:

. Amazon S3

<a name="ueya-1703804893172"></a>. Microsoft Azure Blob Storage

<a name="tvdh-1703804630431"></a>**Cloud SQL**

<a name="iczc-1703872944177"></a>**.概念**

Cloud SQL为本地MySQL、PostgreSQL和SQL Server数据库提供基于云的替代方案。如果您希望减少数据库管理时间，将更多时间投入使用数据库，

<a name="mjqe-1703873306303"></a>则应使用Cloud SQL。在Compute Engine、App Engine和Google Cloud中的其他服务上运行的许多应用都使用CloudSQL来存储数据库。

<a name="2c49-1703872957141"></a>**.for Mysql**

创建 for mysql实例

<a name="lakd-1703873540509"></a>终端连接测试

<a name="dst5-1703872971504"></a>**.数据库灾难恢复**

<a name="nvah-1703877658127"></a>**1.使主实例不可用**

<a name="uiqd-1703877659651"></a>**2.实施灾难恢复**

<a name="ilev-1703877708388"></a>**3.新主启用高可用**

. Cloud SQL的两个实例(主实例和备用实例了位于单个区域(主要区域)内的两个不同地区中。系统将使用区域永久性磁盘同步实例。

。一个Cloud SQL实例（跨区域只读副本）位于另一个区域(辅助区域)。对于灾难恢复，设置跨区域只读副本以使用只读副本设置与主实例同步（使用异步复制)。

·创建高可用性Cloud sQL for MySQL实例。

·使用Cloud sQL for MySQL在Google Cloud 上部署一个跨区域只读副本.

·使用Cloud sQL for MySQL模拟灾难和故障切换情况。

·了解通过将回退过程与Cloud sQl for MySQL搭配使用来恢复初始部署的步骤。

本文档仅重点介绍跨区域灾难恢复故障切换和回退过程。如需了解单区域高可用性故障切换过程请参阅高可用性配置概览。

使主实例不可用-避免脑裂

在以下步骤中，您将通过停止主实例来模拟灾难情况。如果将跨区域只读副本附加到主实例，您必须先分离副本，否则无法停止Cloud sQL 实例。

1\.在Cloud Shell中，从主实例移除跨区域只读副本:

gcloud sql instances patch $cross\_region\_replica\_name l--no-enable-database-replication

当系统提示时，请接受继续操作的选项。

2\.停止主数据库实例:

gcloud sql instances patch $primary\_name --activation-policy NEVER

实施灾难恢复

1\.在Cloud Shell中，将跨区域只读副本提升为独立实例:

gcloud sql instances promote-replica $cross\_region\_replica\_name

<a name="88hm-1703874039693"></a>手动与自动执行的优缺点

<a name="ywx5-1703872998042"></a>**BigQuery(数仓，Sql分析)**

BigQuery是一种全代管式企业数据仓库，可帮助您使用机器学习、地理空间分析和商业智能等内置功能管理和分析数据。BigQuery的无服务器架构允许您使用SQL查询来回答组织面临的最大问题，而无需管理基础架构。BigQuery的可扩缩、分布式分析引擎可让您在几秒钟内查询TB级数据，在几分钟内查询PB级数据。

BigQuery使用针对分析查询进行了优化的列式存储格式来存储数据。BigQuery在表、行和列中显示数据，并完全支持数据库事务语义(ACID)。BigQuery存储会自动跨多个位置进行复制，以提供高可用性。

·了解数据仓库和数据集市中BigQuery资源的常见组织模式。。了解数据集，这是BigQuery的表和视图的顶层容器。

·使用方下方式将数据加载到BigQuery 中:

·使用Storage Write API流式传输数据。

·从本地文件或Cloud Storage批量加载数据，这些数据使用以下格式: Avro、Parquet.ORC、cSv、JSON、Datastore、Firestore格式。

<a name="fdu8-1703879016487"></a>.BigQuery Data Transfer Service可自动注入数据。

<a name="y2zg-1703873024896"></a>**.加载和查询数据**

<a name="bsyq-1703873049958"></a>**Bigtable(HBase竞品)**

Cloud Bigtable是稀疏填充的表，可以扩展到数十亿行和数千列，可让您存储TB级甚至是PB级的数据。每行中都会有一个被编入索引的值;这个值称为行键。Bigtable 能够以低延迟方式存储大量单键数据。它可以低延迟地支持高读写吞吐量，是MapReduce操作的理想数据源。Bigtable通过多个客户端库公开给应用，包括适用于Java的Apache HBase库的受支持扩展程序。因此，它可与开源大数据软件的现有Apache生态系统集成在一起。与自行管理的HBase安装相比，Bigtable强大的后端服务器具有多项关键优势:



·超高扩缩能力。Bigtable的扩缩能力与集群中的机器数成正比。自行管理的HBase安装存在一个设计瓶颈，在达到特定阈值后会对性能造成限制。Bigtable不存在此瓶颈，因此您可以扩展集群以处理更多读取和写入操作。

·易于管理。Bigtable可以透明方式处理升级和重启，而且会自动保持高度的数据耐用性。要复制您的数据，只需为您的实例添加第二个集群，然后系统便会自动开始复制。无需管理副本或区域;只需设计好表的架构，Bigtable就会为您处理剩余的操作。

.无需停机即可调整集群大小。您可以扩大Bigtable集群，运行几个小时以处理某个大型负载，

您可以使用Bigtable来存储和查询以下所有类型的数据:

·时间序列数据，例如多个服务器在一段时间内的CPU和内存使用率。

·营销数据，例如购买记录和客户偏好设置。

·金融数据，例如交易记录、股票价格和货币汇率。

·物联网数据，例如来自电表/气表和家用电器的使用量报告。·图表数据，例如有用户相互间连接方式的信息。

其他存储和数据库选项

Bigtable不是关系型数据库，不支持SQL查询、联接或多行事务。

·如果您需要为联机事务处理(OLTP)系统提供全面的SQL支持，请考虑使用Cloud Spanner或Cloud SQL。

·如果您需要在一个在线分析处理(OLAP)系统中进行互动式查询，请考虑使用BigQuery。

·如果您必须将高度结构化的对象存储在文档数据库中，且支持ACID事务和SQL类查询，请考虑使用Firestore。

<a name="1zx9-1703888243041"></a>·如需以低延迟方式存储内存数据，请考虑使用Memorystore。·如需实时同步用户之间的数据，请考虑使用Firebase 实时数据库。

<a name="oejc-1703873059122"></a>**.数据写入与读取**

列族

<a name="upgu-1703889403023"></a>    c1：value

<a name="xdlt-1703873017651"></a> **Firestore(会话存储)**

<a name="rqfz-1703889554776"></a>是小型结构化数据（如购物车）的理想选择

<a name="bh8z-1703872927361"></a>**Cloud Spanner(数据库跨区域高可用)**

<a name="16o7-1703965577093"></a>**Cloud Run（容器服务）**

<a name="7w27-1703965622477"></a>Cloud Run 是一种托管的容器服务，开发者可以将其容器化的应用程序部署到云上，而无需关心底层的基础设施管理。它支持自动扩展和按使用量计费。

<a name="evlf-1703889764129"></a>**Cloud Data Loss Prevention(损失预防/敏感数据)**

<a name="a5io-1703889582915"></a><a name="4p4w-1741004650375"></a>**GCP 开发专业认证示例**

其他存储和数据库选项

Bigtable不是关系型数据库，不支持SQL查询、联接或多行事务。

·如果您需要为联机事务处理(OLTP)系统提供全面的SQL支持，请考虑使用Cloud Spanner或Cloud SQL。

·如果您需要在一个在线分析处理(OLAP)系统中进行互动式查询，请考虑使用BigQuery。

·如果您必须将高度结构化的对象存储在文档数据库中，且支持ACID事务和SQL类查询，请考虑使用Firestore。

<a name="trfh-1703902114133"></a>·如需以低延迟方式存储内存数据，请考虑使用Memorystore。·如需实时同步用户之间的数据，请考虑使用Firebase 实时数据库。

<a name="arcc-1746687529280"></a>**Google Kubernets Engine**

<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>

` `您正在使用不同的微服务开发应用程序，这些微服务必须保留在群集内部。你希望能够为每个微服务配置特定数量的副本。你还希望能够以统一的方式从任何其他微服务寻址特定的微服务，而不管微服务扩展到多少副本。您计划在 Google Kubernetes Engine 上实施此解决方案。你应该怎么做？ 

A. 将每个微服务部署为一个 Deployment。使用服务在集群中公开部署，并使用服务 DNS 名称从集群内的其他微服务对其进行寻址。 

B. 将每个微服务部署为一个 Deployment。使用 Ingress 在集群中公开 Deployment，并使用 Ingress IP 地址从集群内的其他微服务对 Deployment 进行寻址。 -Deployment 声明管理pod副本

C.将每个微服务部署为 Pod。使用 Service 在集群中暴露 Pod,并使用 Service DNS 名称从集群内的其他微服务寻址微服务.-Service网络服务DNS寻址

D.将每个微服务部署为 Pod。使用 Ingress 暴露集群中的 Pod，并使用 Ingress IP 地址从集群内的其他微服务对 Pod 进行寻址。-Ingress 7层外部 

正确答案 A

A. 将每个微服务部署为一个 Deployment。使用服务在集群中公开部署，并使用服务 DNS 名称从集群内的其他微服务对其进行寻址。 

反馈意见 答：正确，因为 Service 在集群中将有一个 DNS 条目，其他微服务可以使用该条目来寻址 Service 所针对的 Deployment 的 Pod。 

B 不正确，因为 Ingress 使用外部或内部 HTTP（s） 负载均衡器公开服务，并且它不直接应用于 Deployment。 

C 是不正确的，因为 Pod 是微服务的单个实例，而 Deployment 可以配置多个副本。 

D 不正确，因为它结合了选项 B 和 C 的错误。 

\==============================

` `您的应用在 Google Kubernetes Engine （GKE） 集群中作为容器运行。您需要使用一种安全的方法向应用程序添加密钥，以防止通过调用 Kubernetes API 服务器泄露密钥。你应该怎么做？ 

A. 创建 Kubernetes 密钥，并将该密钥作为环境变量传递给容器。  -Secret仅编码

B. 使用云密钥管理服务 （KMS） 密钥在集群上启用 GKE 应用层密钥加密。 -GkE应用层显示base64编码

c.将密钥存储在 Cloud KMS 中。创建一个 Google 服务帐号，以便从 Cloud KMS 读取密钥。以 JSON 格式导出服务帐号密钥，并将 JSON 文件挂载到容器上，作为 ConfigMap 卷，以便从 Cloud KMS 读取 Secret。   

d. 将密钥存储在机密管理器中。创建一个 Google 服务帐户以从 Secret Manager 读取 Secret。创建 Kubernetes 服务帐户以运行容器。使用 Workload Identity 以 Google 服务帐户的身份进行身份验证。 

正确答案 d.将密钥存储在机密管理器中。创建一个 Google 服务帐户以从 Secret Manager 读取 Secret。创建 Kubernetes 

服务帐户以运行容器。使用 Workload Identity 以 Google 服务帐户的身份进行身份验证。 

反馈意见 A 不正确，因为 Kubernetes Secret 只对字符串进行编码，任何能够读取该密钥的人都可以对其进行解码。 

B 不正确，因为 GKE 应用层密钥加密仍将密钥显示为 Kubernetes API 服务器中的 base64 编码字符串。 

C 不正确，因为 Cloud KMS 用于存储加密密钥，而不是实际的密钥。您还将 Google 服务帐户密钥作为卷传入，如果任何人都可以读取 Secrets，则可以读取该卷。 

D 是正确的，因为它提供了存储 Secret 的安全服务，也提供了使用 Workload Identity 获取 Secret 的安全方法。 

\============================== 

您可以使用 Istio 在 Google Kubernetes Engine （GKE） 上管理微服务应用程序。您可以通过在 GKE 集群上实施 Istio AuthorizationPolicy、Kubernetes NetworkPolicy 和 mTLS 来保护微服务之间的通信通道。您发现两个 Pod 之间对特定 URL 的 HTTP 请求失败，而 Pod 之间对其他 URL 的其他请求成功。连接问题的原因是什么？ 

A。Kubernetes NetworkPolicy 资源阻止了 Pod 之间的 HTTP 流量。-NetworkPolicy仅作用pod之间，AuthorizationPolicy允许http

B。发起 HTTP 请求的 Pod 正在尝试通过不正确的 TCP 端口连接到目标 Pod。

C.群集的 AuthorizationPolicy 阻止针对应用程序中特定路径的 HTTP 请求。  

D.集群在宽松模式下配置了 mTLS，但 Pod 的 sidecar 代理以纯文本形式发送未加密的流量。 

反馈意见 A 不正确，因为 Kubernetes NetworkPolicy 资源允许您阻止 Pod 组之间的 HTTP 流量，但不能阻止所选路径的 HTTP 流量。（ https://kubernetes.io/docs/concepts/services-networking/network-policies/ ）。 

B 不正确，因为如果客户端 Pod 使用不正确的端口与服务器通信，则所有 URL 路径的 Pod 请求都将超时。 

C 是正确的，因为 Istio 授权策略允许您阻止特定 URL 路径 （https://istio.io/latest/docs/tasks/security/authorization/authz-http/） 的 pod 之间的 HTTP 方法 https://istio.io/latest/docs/tasks/security/authorization/authz-http/。  

D 不正确，因为使用 Istio 的 mTLS 配置不会导致 HTTP 请求失败。在宽松模式（默认配置）下，服务可以接受纯文本和 mTLS 加密流量 （ https://istio.io/latest/docs/tasks/security/authentication/mtls-migration/ ）。 

\==============================

您正在开发一个基于微服务的应用程序，该应用程序将在 Google Kubernetes Engine （GKE） 上运行。某些服务需要访问不同的 Google Cloud API。您应该如何按照 Google 推荐的最佳做法在集群中设置这些服务的身份验证？（二选一） 

A. 使用附加到 GKE 节点的服务帐户。 -无权限分离，无日志

B. 通过 gcloud 命令行工具在集群上启用工作负载标识。  

C. 从 Secret Manager 访问 Google 服务帐户密钥。 

D. 将 Google 服务帐户密钥存储在 Secret Manager 中。 

E. 使用 gcloud 通过 roles/iam.workloadIdentityUser 绑定 Google 服务帐户和 Kubernetes 服务帐户。  

反馈意见 B E

A 不正确。虽然它可以工作，但所有服务都使用相同的服务帐户，没有权限分离，也没有详细的日志记录。 

B 和 E 将 GKE 和 Google 服务帐号一起关联起来，因此 GKE 可以使用 Google 服务帐号对服务进行身份验证。 

C 不正确。虽然这是可行的，但这不是工作负载标识的推荐做法，因为服务帐户的强制密钥轮换。 

D 不正确。虽然这是可行的，但这不是工作负载标识的推荐做法，因为服务帐户的强制密钥轮换。 

E 和 B 同时将 GKE 和 Google 服务帐号关联起来，因此 GKE 可以使用 Google 服务帐号对服务进行身份验证

\==============================

贵公司的产品团队根据客户需求提出了一项新要求，即自动扩展在 Google Kubernetes Engine （GKE） 集群中运行的无状态分布式服务。您希望找到一种可以最大程度地减少更改的解决方案，因为此功能将在两周内上线。你应该怎么做？ 

A. 部署垂直 Pod 自动缩放程序，并根据 CPU 负载进行缩放。 

B. 部署垂直 Pod 自动缩放程序，并根据自定义指标进行缩放。 --垂直缩放需修改应用程序

` `C. 部署水平 Pod 自动缩放程序，并根据 CPU 负载进行缩放。  

D. 部署水平 Pod 自动缩放程序，并根据自定义指标进行缩放。 --自定义指标需Cloud Monitoring 集成

反馈意见 

答：A不正确：这对分布式应用程序没有帮助。 

B. 不正确：这可行，但需要集成 Cloud Monitoring 并可能修改应用程序。这也不适用于分布式应用程序。 

C. 正确：这将需要对代码进行最少的更改并符合要求。 

D. 不正确：这可行，但需要 Cloud Monitoring 集成和可能的应用程序修改。

` `==============================

您正在开发一个将在 Google Cloud 上运行的 Web 应用程序。预计传入用户流量的速率是不可预测的，大多数日子没有流量，而其他日子则会出现大幅峰值。您需要应用程序自动纵向扩展和缩减，并且需要最大程度地降低与运行应用程序相关的成本。你应该怎么做？ 

A. 使用 Firestore 作为数据库构建应用程序。将应用部署到 Cloud Run。 -C Run支持负载到零其余不行。

B. 使用 Firestore 作为数据库构建应用程序。将应用程序部署到 Google Kubernetes Engine Standard 集群。 

C. 使用 Cloud SQL 作为数据库构建应用。将应用程序部署到 Google Kubernetes Engine Autopilot 群集。 

D. 使用 Firestore 作为数据库构建应用程序。将应用部署到具有自动缩放功能的 Compute Engine 托管实例组。 

正确答案 A

A. 使用 Firestore 作为数据库构建应用程序。将应用部署到 Cloud Run。 

反馈意见 答是正确的。Cloud Run 支持扩展到零。此外，Firestore 的成本仅为存储。因此，当没有流量时，运营成本为零。 

B 不正确，因为 GKE 不会扩展到零。 

C 不正确，因为 GKE 不会缩放到零）。此外，运行 Cloud SQL 也会产生相关费用。 

D 不正确。Compute Engine 管理无法扩展到零的实例。它至少需要一个实例才能运行。 

\============================== 

您希望将在 Knative 中运行的本地容器迁移到 Google Cloud。您需要确保迁移不会影响应用程序的部署策略，并且您希望使用完全托管的服务。您应该使用哪种 Google Cloud 服务来部署容器？ 

A. 云运行 B. 计算引擎 C. 谷歌 Kubernetes 引擎  D. App Engine 灵活环境 

正确答案 A. 云运行 

反馈意见 答：A正确：Cloud Run 利用 Knative Serverless 框架，让您可以灵活地在任何 Knative 支持的集群中运行工作负载。 

B. 不正确：使用 Compute Engine 意味着您要手动安装和维护 Google Kubernetes Engine 和 Knative，并且开销会改变部署策略。 

C. 不正确：使用 GKE，您仍然需要管理 Worker 节点，而且它不是完全托管的服务。此外，您还需要对应用程序部署策略进行大量更改。 

D. 不正确：虽然 App Engine Flexible 环境可以运行容器，但您需要对应用部署策略进行大量更改。

\==============================

` `贵单位最近启动了一项计划，将其旧版应用重新平台化到 Google Kubernetes Engine 上。您需要将整体式应用程序分解为微服务。多个实例对存储在共享文件系统上的配置文件具有读写访问权限。您希望最大程度地减少管理此转换所需的工作量，并且希望避免重写应用程序代码。你应该怎么做？ 

A：创建新的 Cloud Storage 存储分区，并通过 FUSE 将其挂载到容器中。 -FUSE不支持并发和文件锁定

B. 创建新的永久性磁盘，并将该卷装载为共享 PersistentVolume。  -不是读写多的

C. 创建新的 Filestore 实例，并将该卷挂载为 nfs PersistentVolume。 -读写多

D. 创建新的 ConfigMap 和 volumeMount 来存储配置文件的内容。  -ConfigMap无法从pod写入

正确答案 

C. 创建新的 Filestore 实例，并将该卷挂载为 nfs PersistentVolume。 

反馈意见 A 不正确，因为 Cloud Storage FUSE 不支持并发和文件锁定。 

B 不正确，因为持久性磁盘 PersistentVolume 不是读写多的。它只能是读写一次或多次读写。 

C 是正确的，因为它是 Google Kubernetes Engine 中唯一可用于文件系统访问的托管、受支持的读-写-多存储选项。 

D 不正确，因为 ConfigMap 无法从 Pod 写入。  

\==============================

您正处于将现场数据中心迁移到google Clout的最后阶段，您正在快速接近截止日期，并发现web apl正在被指定用于退役的服务器上运行。在迁移到Google Cloud时，您需要推荐一种更新此APL的解决方案。现代化的Web APL必须满足以下要求：

Python3.x中每个月末高流量期间的自动标度

开发人员必须能够快速部署新版本，以响应频繁的代码更改。

您希望最小化运行服务的成本、工作量和操作开销。您应该做什么？

A.在 App Engine 柔性环境中对代码进行现代化改造和部署。 

B. 在 Cloud Run 上对代码进行现代化改造和部署。 -成本最低，0-X实例自动扩缩

C. 将现代化应用部署到 n1-standard-1 Compute Engine 实例。 

D. 要求开发团队重写应用程序，使其在 Google Kubernetes Engine 上作为容器运行。  

正确答案 B. 在 Cloud Run 上对代码进行现代化改造和部署。 

反馈意见 A 不正确。虽然这种方法满足所有要求，但它并不是成本最低的方法。使用 App Engine Flexible 时，始终至少有一个实例处于在线状态。 

B 是正确的。Cloud Run 满足所有要求。它;即用即付设计为从 0-x 实例自动扩展，并且部署只需几秒钟而不是几分钟。 

C 不正确。虽然这是一个解决方案，但它并不能满足所有要求。单个实例不会自动缩放。最后，要满足所有要求，需要额外的努力和持续的服务器管理、设置等。 

D 不正确。虽然这确实满足了所有要求，但它不是成本最低的，也不是最不费力的。

\==============================

`  `您已在Google Kubernetes Engine （GKE） 集群中部署了 Web 应用程序。您正在查看 Cloud Monitoring 指标，发现集群的 CPU 负载全天都在波动。为了最大限度地提高性能，同时最大限度地降低成本，您希望自动调整 Pod 和注释的数量。你应该怎么做？

A. 修改托管实例组 （MIG） 以启用自动缩放，以便根据 CPU 负载配置最大和最小节点数。 -不应在GKE创建的实例组上使用虚拟机的自动缩放功能。

B. 在 GKE 集群上启用 Cluster Autoscaler，并将 Horizontal Pod Autoscaler （HPA） 配置为根据 CPU 负载自动扩展工作负载。

C. 在 GKE 集群上启用 Cluster Autoscaler，并将 HPA 配置为基于自定义指标自动扩展工作负载。  

D. 修改 MIG 以启用自动缩放以根据 CPU 负载配置最大和最小节点数量，并将垂直 Pod 自动缩放程序 （VPA） 配置为根据 CPU 负载缩放工作负载。 

正确答案 B. 在 GKE 集群上启用 Cluster Autoscaler，并将 Horizontal Pod Autoscaler （HPA） 配置为根据 CPU 负载自动扩展工作负载。 

反馈意见 A 不正确，因为您不应在 GKE 创建的实例组上使用 Compute Engine 的自动缩放功能。 

B 是自动缩放 Kubernetes 部署的推荐方法。 

C 不正确，因为默认情况下启用了 CPU 指标，并且不需要自定义指标。 

<a name="jbbj-1703902082056"></a>D 不正确，因为您不应在 GKE 创建的实例组上使用 Compute Engine 的自动扩展功能。  

<a name="xobq-1746687529282"></a>**Cloud Storage**

<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>

您的团队正在为您的公司开发电子商务平台。用户将登录网站并将商品添加到他们的购物车中。用户将在 30 分钟不活动后自动注销。当用户重新登录时，

他们的购物车应该可用。在遵循 Google 推荐的最佳做法的同时，您应如何存储用户的会话和购物车信息？ 

A. 将会话和购物车信息存储在本地内存中，并在全局外部 HTTP（S） 负载平衡器中启用基于 Cookie 的会话相关性。 

B. 将购物车信息存储在 Cloud Storage 上的对象中，其中对象名称是会话标识符。  

C. 将会话和购物车信息存储在 BigQuery 中。 

D. 将会话信息存储在 Memorystore for Redis 中，将购物车信息存储在 Firestore 中。 

正确答案 

D. 将会话信息存储在 Memorystore for Redis 中，将购物车信息存储在 Firestore 中。 

反馈意见 A 不正确，因为本地内存在进程终止时会丢失，因此您将丢失购物车信息。 

B 不正确，因为访问 Cloud Storage 存储分区的速度较慢且会话信息成本高昂。这不是 Google Cloud 的最佳做法。 

C 不正确，因为 BigQuery 无法处理对购物车和会话进行的频繁更新。 

D 是正确的，因为 Memorystore 速度很快，是存储会话信息的标准解决方案，而 Firestore 是小型结构化数据（如购物车）的理想选择。如果需要，

用户将使用新会话映射到购物车。 

\==============================

您最近开发了一个网络应用，用于每天将日志数据传输到 Cloud Storage 存储分区。经过身份验证的用户将定期查看前两周的日志，以查找关键事件。

之后，外部审计师将每年审查一次日志。数据必须存储不少于 7 年。您希望提出一个满足这些要求并最大限度地降低成本的存储解决方案。你应该怎么做？

（二选一） 

A. 使用存储桶锁定功能设置数据的保留策略。  

B. 运行计划作业，将超过 14 天的对象的存储类设置为 Coldline。 

C. 为需要访问 Coldline 存储桶的用户创建 JSON Web 令牌 （JWT）。 

D. 创建生命周期管理策略，将超过 14 天的对象的存储类设置为 Coldline。 

E. 创建生命周期管理策略，将超过 14 天的对象的存储类设置为“近线”。 



正确答案 

A. 使用存储桶锁定功能设置数据的保留策略。 

D. 创建生命周期管理策略，将超过 14 天的对象的存储类设置为 Coldline。 

反馈意见 A 是正确的，因为存储桶锁定功能将强制执行所需的保留策略。 

B 不正确，因为应使用生命周期管理策略设置存储类。 

C 不正确。JWT 可用于身份验证，但不应用于确定对象生命周期。 

D 是正确的，因为生命周期管理策略将更改存储类以最大限度地降低成本。 

E 不正确，因为如果数据仅每年访问一次，则存档或 Coldline 存储比近线存储更经济。 

\==============================

您正在开发一个应用，用于存储和访问 Cloud Storage 存储分区中的对象。为了遵守法规要求，您需要确保所有对象在初始创建后至少 7 年内可用。

3 年多前创建的对象很少被访问（每年不到一次）。您需要配置对象存储，同时确保存储成本得到优化。你应该怎么做？（二选一） 

A. 在存储桶上设置保留策略，期限为 7 年。 

B. 在对象的前缀名称中包含创建时间，并使用 IAM 条件仅提供对对象创建日期后 7 年内对象的读取访问权限。 



C. 启用对象版本控制，以防止对象在创建后的 7 年内被意外删除。 

D. 在存储桶上创建对象生命周期策略，以便在 3 年后将对象从标准存储移动到存档存储。 

E. 实现一个 Cloud Function，用于检查存储桶中每个对象的期限，并将超过 3 年的对象移动到具有 Archive Storage 类的第二个存储桶。 

使用 Cloud Scheduler 按每日计划触发 Cloud Function。 



正确答案 

A. 在存储桶上设置保留策略，期限为 7 年。 

D. 在存储桶上创建对象生命周期策略，以便在 3 年后将对象从标准存储移动到存档存储。 

反馈意见 答是正确的，因为 Cloud Storage 提供了配置保留生命周期规则的选项。 

B 不正确，因为它不是实现数据保留要求的推荐方法。 

C 不正确，因为它不保证对象在创建对象后的 7 年内不会被删除。 

D 是正确的，因为它是实现存储生命周期策略以将对象从标准层移动到存档层的最简单且推荐的方法。 

E 不正确，因为您不需要两个存储桶来将对象存储在两个存储层上。 

\============================== 

您已经开发了一个应用程序，并希望将其托管在 Cloud Run 上。此应用程序将日志记录作为文本写入本地文件。您希望将日志写入 Cloud Logging，

同时尽量减少需要维护的代码量。你应该怎么做？ 

A：在代码中导入 Cloud Logging 库，并使用它来编写日志。 

B. 使用编程语言记录器将日志写入标准输出 （stdout） 和标准错误 （stderr） 流。 

C. 将日志文件公开给  www.mycompany.com/logs 。使用浏览器手动下载文件并将其上传到 Cloud Storage。 

D. 使用 cron 计划作业，每天将日志文件复制到 Cloud Storage 一次。  

正确答案 

B. 使用编程语言记录器将日志写入标准输出 （stdout） 和标准错误 （stderr） 流。 

反馈意见 一个。这是不正确的。虽然从技术上讲可以使用该库，但这将导致需要维护大量代码。 

湾。这是正确的。Cloud Run 通过 stdout 和 stderr 直接集成到 Cloud Logging。 

三.这是不正确的。此任务必须手动执行。此外，这种方法也不是最安全的。 

<a name="xlkn-1703802890641"></a>D.这是不正确的。虽然可以将数据复制到 Cloud Storage 存储分区中，但这并不能帮助我们实现在 Cloud Logging 中存储日志数据的目标。 

<a name="u1ih-1746687529283"></a>**Cloud SQL**

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SQL



您正在将应用部署在与 Cloud SQL 通信的 Google Kubernetes Engine 实例上。您将使用 Cloud SQL 身份验证代理，让您的应用能够使用与

应用实例关联的服务帐号与数据库进行通信。您希望对分配给服务帐户的角色遵循最小特权原则。你应该怎么做？ 

A. 分配“项目编辑者”角色。 B. 分配“项目所有者”角色。  C. 分配 Cloud SQL 客户端角色。 D. 分配 Cloud SQL 编辑者角色。 

正确答案 

C. 分配 Cloud SQL 客户端角色。 

反馈意见 A 不正确，因为服务帐号只需连接到 Cloud SQL，而 Google 建议的最佳做法是提供所需的最少访问权限。 

B 不正确，因为服务帐号只需连接到 Cloud SQL，而 Google 建议的最佳做法是提供所需的最少访问权限。 

C 是正确的，因为 Cloud SQL 客户端角色提供了连接到 Cloud SQL 所需的最低访问权限。 

D 不正确，因为服务帐号只需连接到 Cloud SQL，而 Google 建议的最佳做法是提供所需的最少访问权限。 

\============================

您的团队管理一个web应用程序，该应用程序目前将用户会话信息存储在一个在InstitutedPostgreSQL数据库中。

并将web应用程序迁移到GoogleCloud。您在迁移之后检测到了很高的延迟。您需要进行一些快速测试来收集数据点，

然后向您的技术领导提供建议，以提高性能并使其成为一种具有成本效益的解决方案。

.首先，您希望将数据库迁移到GoogleCloud，而不更改

架构，以查看延迟是否减少。

.接下来，您需要评估如何用云管理的NoSQL数据库替换PostgreSQL，以存储用户会话信息。

您希望使用托管服务并快速收集数据点。你该怎么做？

A：将数据库迁移到 Cloud SQL。然后将数据导入 Cloud Storage。 B. 将数据库迁移到 BigQuery。然后，以本机模式将数据导入 Firestore。 

C. 将数据库迁移到 Cloud SQL。然后，以本机模式将数据导入 Firestore。 

D. 在 Google Cloud 中创建 Compute Engine 虚拟机实例，并安装 PostgreSQL 和 MongoDB Server 软件。将数据库迁移到新的 PostgreSQL，

然后将数据迁移到 MongoDB。 

正确答案 

C. 将数据库迁移到 Cloud SQL。然后，以本机模式将数据导入 Firestore。 

反馈意见 A 不正确。Cloud Storage 不是用于存储用户会话信息的有效 NoSQL 数据库。 

B 不正确。BigQuery 是一个数据仓库。它对插入的行的更新/删除功能有限，因此对于用户会话数据来说是一个糟糕的选择，因为用户会话数据会随着与用

户会话的进行而变化。 

C 是正确的。Cloud SQL 是受管理的 PostgreSQL 数据库，迁移时无需更改任何架构。建议使用本机模式下的 Firestore 来存储用户会话信息，这是此

测试的自然选择。 

D 不正确。这不使用任何托管服务，并且会增加测试时间，因为它需要数据库服务器管理。 

\================================ 

贵公司有一款成功的多人游戏，在美国很受欢迎。现在，它希望扩展到其他地区。它正在推出一项新功能，允许用户交易积分。此功能将适用于全球用户。贵公司当前的MySQL 后端已达到托管游戏的 Compute Engine 

实例的限制。你的公司希望迁移到其他数据库，以提供跨区域的全局一致性和高可用性。他们应该选择哪个数据库？ 

A. BigQuery B. 云 SQL  C. 云扳手 D. 云大表 

正确答案 

C. 云扳手 

反馈意见 A 不正确，因为 BigQuery 不能用作事务性数据库。 

B 不正确，因为 Cloud SQL 无法提供跨区域的高可用性。 

C 是正确的，因为只有 Cloud Spanner 才能提供全局一致性和可用性。 

D 不正确，因为 Cloud Bigtable 不提供全局可用性。 

\================================  

您的公司计划扩展其分析用例。其中一个新用例要求数据分析师使用 SQL 近乎实时地分析事件。您期望快速增长，并希望尽可能多地使用托管服务。你应该怎么做？ 

A. 创建 Pub/Sub 主题和订阅。将事件从源流式传输到 Pub/Sub 主题。利用 Dataflow 将这些事件提取到 BigQuery 中。  

B. 创建发布/订阅主题和订阅。将事件从源流式传输到 Pub/Sub 主题。利用 Dataflow 将这些事件提取到 Cloud Storage 中。 

C. 创建发布/订阅主题和订阅。将事件从源流式传输到 Pub/Sub 主题。利用 Dataflow 以数据存储模式将这些事件摄取到 Firestore 中。 

D. 在大型 Compute Engine 实例上创建 Kafka 实例。将事件从源流式传输到 Kafka 管道。利用 Dataflow 将这些事件提取到 Cloud Storage 中。 

反馈意见 答是正确的，因为所涉及的所有三个产品都可以扩展到大量数据，并且将数据写入 BigQuery 允许通过 SQL 进行即时分析。 

B 不正确，因为 Cloud Storage 不适合插入单个事件并通过 SQL 对其进行分析。 

C 不正确，因为数据存储模式下的 Firestore 不适合插入单个事件并对其进行分析。 

<a name="savw-1703884741453"></a>D 不正确，因为此解决方案不提供完全托管的解决方案。 

<a name="8lvo-1746687529284"></a>**BigQuery**

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

您的团队开发了一个移动 Web 应用程序，全球用户可在其中对热门主题进行投票。对于每个主题，您预计在每个 30 分钟的投票窗口内会有非常高的投票量。您需要在每 30 分钟的窗口内捕获并计算每个主题的投票。您还需要存储选票以供将来分析和报告。你应该怎么做？ 

A：将投票保存到 Memorystore，然后使用 Cloud Functions 将计票结果插入到 BigQuery 中。在 Google Data Studio 中显示结果。

B. 将投票发布到 Pub/Sub，并使用 Datafow 管道将计票和投票插入到 BigQuery 中。在 Google Data Studio 中显示结果。 

C. 将投票发布到 Pub/Sub，并使用 Cloud Functions 将计票和投票插入到 Cloud Storage 中。在 Google Data Studio 中显示结果。 

D. 使用 Firebase 对移动用户进行身份验证，并将投票直接发布到 Firestore。将投票结果导出为 CSV 文件，然后将其导入 Google 表格以生成报告。 

反馈意见 A. 不正确。Memorystore 不是持久性数据存储，可能会丢失投票。 

B. 正确。Pub/Sub 支持每秒引入数百万条记录，并保证消息的传递。Dataflow 可以在按主题分组的窗口中聚合投票。应使用 BigQuery 进行分析。 

C. 不正确。使用 Cloud Functions 进行窗口化和分组需要将状态存储在中间数据存储中。此外，将原始数据存储在 blob 存储中会使使用 Data Studio 进行分析效率低下。 

D. 不正确。Google 表格可以执行的分组和分析操作存在限制。

\================================  

您的团队正在使用 Cloud Run 将每条发布/订阅消息写入 Cloud Storage 对象和 BigQuery 表。您希望将运营开销降至最低。您应该实现哪种架构？  

A 不正确，因为这会将一半的消息写入 BigQuery，另一半写入 Cloud Storage，这不符合需求。 -消息队列被消费

B 是正确的，因为每个 App Engine 服务都会收到自己的消息来写入，并且可以独立重试/失败。 

C 不正确，因为将邮件处理到一个系统时出现故障可能会导致重复写入 BigQuery 或 Google Cloud Storage。 

<a name="nks9-1703884709102"></a>D 不正确，因为它重复了消息发送费用，并要求将消息发送到两个不同的主题两次，这会增加成本、管理其他主题的需要以及客户端上的复杂性。

<a name="wtm8-1746687529285"></a>**BigTable**

` `您正在分析应用程序的性能。您发现集群中某些 Cloud Bigtable 

表的使用量远远高于其他表，从而导致最终用户的应用性能不一致。您会发现某些平板电脑具有大量名称相似的行键，并且使用率很高，而其他平板电脑则处于空闲状态。您发现用户的邮政编码是行键的第一个组成部分，并且您的应用程序被源自该邮政编码的配置文件大量使用。您希望更改生成行键的方式，使其具有人类可读性，并使Cloud Bigtable 需求在集群中更均匀地分布。你应该怎么做？ 

A. 使用串行生成的整数值。 B. 使用行内容的 MD5 哈希的子集。  C. 使用多个人类可读属性的串联。 

D. 使用以毫秒为单位表示的 UNIX 纪元样式时间戳。 

正确答案 

C. 使用多个人类可读属性的串联。 

反馈意见 A 不正确，因为根据基础值的分布，串行生成的整数值可能会导致热点。 

B 不正确，因为这不再是推荐的最佳做法：它使解决问题变得困难。  

C 是正确的，因为使用足够数量的分隔属性可以提供足够的扩展。  

<a name="l11q-1703884660135"></a>D 不正确，因为时间戳不适合行键，在这种情况下，如果在同一毫秒内连续执行多个更新，则无意中导致 ID 冲突。 


